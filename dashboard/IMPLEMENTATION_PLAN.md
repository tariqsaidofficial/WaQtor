# ğŸ“‹ Ø®Ø·Ø© Ø§Ù„ØªÙ†ÙÙŠØ° Ø§Ù„Ø´Ø§Ù…Ù„Ø© - WaQtor Dashboard

## ğŸ¯ **Ù†Ø¸Ø±Ø© Ø¹Ø§Ù…Ø©:**

ØªÙ… ÙØ­Øµ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø© ÙˆØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨. Ø§Ù„Ø®Ø·Ø© Ù…Ù‚Ø³Ù…Ø© Ø¥Ù„Ù‰ **7 Ù…Ø±Ø§Ø­Ù„** Ù…Ù†Ø¸Ù…Ø©.

---

## ğŸ”’ **Ø§Ù„Ø£Ù…Ø§Ù† ÙˆØ§Ù„Ø®ØµÙˆØµÙŠØ©:**

### âœ… **End-to-End Encryption (E2E)**
- **Ø§Ù„Ø­Ø§Ù„Ø©:** âœ… **Ù…Ø¯Ø¹ÙˆÙ… Ø¨Ø§Ù„ÙƒØ§Ù…Ù„**
- **Ø§Ù„ØªÙØ§ØµÙŠÙ„:** WaQtor Ù…Ø¨Ù†ÙŠ Ø¹Ù„Ù‰ whatsapp-web.js v1.34.1 Ø§Ù„Ø°ÙŠ ÙŠØ³ØªØ®Ø¯Ù… Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„ WhatsApp Ø§Ù„Ø±Ø³Ù…ÙŠ
- **Ø§Ù„Ù…ÙŠØ²Ø©:** Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ù…Ø´ÙØ±Ø© Ù…Ù† Ø·Ø±Ù Ù„Ø·Ø±Ù ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ø¹Ø¨Ø± WhatsApp
- **Ø§Ù„Ù…ØµØ¯Ø±:** Landing page - "Your messages are secured with WhatsApp's end-to-end encryption protocol"

### ğŸ”„ **GDPR Compliance (Ù‚ÙŠØ¯ Ø§Ù„ØªØ·ÙˆÙŠØ±)**
- **Ø§Ù„Ø­Ø§Ù„Ø©:** ğŸ”„ **Partially Implemented**
- **Ù…ÙˆØ¬ÙˆØ¯ Ø­Ø§Ù„ÙŠØ§Ù‹:**
  - âœ… Privacy Policy link (ÙÙŠ Landing page)
  - âœ… Data stored locally (SQLite)
  - âœ… No third-party data sharing
- **Ù…Ø·Ù„ÙˆØ¨ Ø¥Ø¶Ø§ÙØªÙ‡:**
  - âŒ Privacy Policy ØµÙØ­Ø© ÙƒØ§Ù…Ù„Ø©
  - âŒ Terms of Service ØµÙØ­Ø©
  - âŒ Cookie Consent Banner
  - âŒ Data Export functionality (ØªØµØ¯ÙŠØ± Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª)
  - âŒ Right to be Forgotten (Ø­Ø°Ù Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª)
  - âŒ Data Retention Policies
  - âŒ User Consent Management
  - âŒ Audit Logs Ù„Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø³Ø§Ø³Ø©

---

## ğŸ“Š **Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø© Ø­Ø§Ù„ÙŠØ§Ù‹:**

### âœ… **Ø§Ù„ØµÙØ­Ø§Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©:**
```
/app/(main)/
â”œâ”€â”€ dashboard/          âœ… Ù…ÙˆØ¬ÙˆØ¯Ø© (Prime Dashboard)
â”œâ”€â”€ campaigns/          âœ… Ù…ÙˆØ¬ÙˆØ¯Ø©
â”œâ”€â”€ messages/           âœ… Ù…ÙˆØ¬ÙˆØ¯Ø©
â”œâ”€â”€ smartbot/           âœ… Ù…ÙˆØ¬ÙˆØ¯Ø©
â”œâ”€â”€ interactive/        âœ… Ù…ÙˆØ¬ÙˆØ¯Ø©
â”œâ”€â”€ reports/            âœ… Ù…ÙˆØ¬ÙˆØ¯Ø©
â””â”€â”€ settings/           âœ… Ù…ÙˆØ¬ÙˆØ¯Ø©
```

### âœ… **ØµÙØ­Ø§Øª Full-Page:**
```
/app/(full-page)/
â”œâ”€â”€ auth/
â”‚   â”œâ”€â”€ login/          âœ… Ù…ÙˆØ¬ÙˆØ¯Ø©
â”‚   â”œâ”€â”€ access/         âœ… Ù…ÙˆØ¬ÙˆØ¯Ø©
â”‚   â””â”€â”€ error/          âœ… Ù…ÙˆØ¬ÙˆØ¯Ø©
â”œâ”€â”€ landing/            âœ… Ù…ÙˆØ¬ÙˆØ¯Ø©
â””â”€â”€ pages/
    â””â”€â”€ notfound/       âœ… Ù…ÙˆØ¬ÙˆØ¯Ø©
```

### âœ… **UI Components:**
```
/app/(main)/uikit/
â”œâ”€â”€ button/             âœ… Ù…ÙˆØ¬ÙˆØ¯Ø©
â”œâ”€â”€ charts/             âœ… Ù…ÙˆØ¬ÙˆØ¯Ø©
â”œâ”€â”€ file/               âœ… Ù…ÙˆØ¬ÙˆØ¯Ø©
â”œâ”€â”€ formlayout/         âœ… Ù…ÙˆØ¬ÙˆØ¯Ø©
â”œâ”€â”€ input/              âœ… Ù…ÙˆØ¬ÙˆØ¯Ø©
â”œâ”€â”€ message/            âœ… Ù…ÙˆØ¬ÙˆØ¯Ø©
â””â”€â”€ table/              âœ… Ù…ÙˆØ¬ÙˆØ¯Ø©
```


## ğŸš€ **Ø§Ù„Ù…Ø±Ø§Ø­Ù„ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©:**

---

### **Ø§Ù„Ù…Ø±Ø§Ø­Ù„ Ø§Ù„Ù…ÙƒØªÙ…Ù„Ø© (1-7):** âœ…

#### **Ø§Ù„Ù…Ø±Ø­Ù„Ø© 1: ØªØ­Ø¯ÙŠØ«Ø§Øª Topbar** âœ…
- ØªØ­Ø³ÙŠÙ† Avatar System (Label + Circle, Image + Circle, Gravatar, Badge)
- Profile dropdown Ù…Ø¹ Quick Actions
- **Ø§Ù„Ù…Ù„ÙØ§Øª:** `/components/layout/AppTopbar.tsx`, `/_topbar.scss`

#### **Ø§Ù„Ù…Ø±Ø­Ù„Ø© 2: ØµÙØ­Ø© Profile** âœ…
- Ø¹Ø±Ø¶ ÙˆØªØ¹Ø¯ÙŠÙ„ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ØŒ ØªØºÙŠÙŠØ± ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±
- **Ø§Ù„Ù…Ù„ÙØ§Øª:** `/app/(main)/profile/page.tsx`, `/components/profile/ProfileCard.tsx`

#### **Ø§Ù„Ù…Ø±Ø­Ù„Ø© 3: ØµÙØ­Ø© About** âœ…
- Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ØŒ Ø§Ù„Ø¥ØµØ¯Ø§Ø±ØŒ Ø§Ù„ÙØ±ÙŠÙ‚
- **Ø§Ù„Ù…Ù„ÙØ§Øª:** `/app/(main)/about/page.tsx`

#### **Ø§Ù„Ù…Ø±Ø­Ù„Ø© 4: Ù†Ø¸Ø§Ù… BlockUI** âœ…
- ØªØ·Ø¨ÙŠÙ‚ BlockUI Ø¹Ù„Ù‰ Campaigns, Messages, SmartBot
- **Ø§Ù„Ù…Ù„ÙØ§Øª:** `/app/(main)/{campaigns,messages,smartbot}/page.tsx`

#### **Ø§Ù„Ù…Ø±Ø­Ù„Ø© 5: Tag "New"** âœ…
- Ø¥Ø¶Ø§ÙØ© Tag Ù„Ù„ØµÙØ­Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© ÙÙŠ Sidebar
- **Ø§Ù„Ù…Ù„ÙØ§Øª:** `/components/layout/AppMenu.tsx`

#### **Ø§Ù„Ù…Ø±Ø­Ù„Ø© 6: ScrollTop** âœ…
- Ø²Ø± ScrollTop ÙÙŠ Layout Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
- **Ø§Ù„Ù…Ù„ÙØ§Øª:** `/app/(main)/layout.tsx`

#### **Ø§Ù„Ù…Ø±Ø­Ù„Ø© 7: ØªØ­Ø³ÙŠÙ† UI Components** âœ…
- ØµÙØ­Ø§Øª Badge, Tag, Chip, Avatar ÙÙŠ UIKit
- **Ø§Ù„Ù…Ù„ÙØ§Øª:** `/app/(main)/uikit/{badge,tag,chip,avatar}/page.tsx`

---

## ğŸ¨ **Ø§Ù„ØªØµÙ…ÙŠÙ… Ø§Ù„Ù…ÙˆØ­Ø¯:**

### **Ø§Ù„Ø£Ù„ÙˆØ§Ù†:**
```scss
$primary: #0f766e;        // WhatsApp green
$success: #16a34a;        // Green
$warning: #f59e0b;        // Orange
$danger: #ef4444;         // Red
$info: #3b82f6;           // Blue
```

### **Ø§Ù„Ù…Ø³Ø§ÙØ§Øª:**
```scss
$spacing-xs: 0.25rem;     // 4px
$spacing-sm: 0.5rem;      // 8px
$spacing-md: 1rem;        // 16px
$spacing-lg: 1.5rem;      // 24px
$spacing-xl: 2rem;        // 32px
```

### **Border Radius:**
```scss
$border-radius-sm: 6px;
$border-radius-md: 12px;
$border-radius-lg: 16px;
```

---

## ğŸ“ **LocalStorage Keys:**

```typescript
// User Settings
user_name: string
user_avatar: string
user_email: string
user_phone: string

// Branding
app_logo: string
app_logo_text: string
app_show_logo_text: boolean

// Subscriptions
subscription_status: boolean
subscription_expiry: string
access_codes: string[]

// UI Preferences
theme: string
compact_mode: boolean
sidebar_collapsed: boolean
```

---

## ğŸ”„ **ØªØ±ØªÙŠØ¨ Ø§Ù„ØªÙ†ÙÙŠØ° Ø§Ù„Ù…Ù‚ØªØ±Ø­:**

```
1. âœ… Ø§Ù„Ù…Ø±Ø­Ù„Ø© 1: ØªØ­Ø³ÙŠÙ† Topbar Avatar (30 Ø¯Ù‚ÙŠÙ‚Ø©)
2. ğŸ“ Ø§Ù„Ù…Ø±Ø­Ù„Ø© 6: Ø¥Ø¶Ø§ÙØ© ScrollTop (15 Ø¯Ù‚ÙŠÙ‚Ø©)
3. ğŸ“ Ø§Ù„Ù…Ø±Ø­Ù„Ø© 5: Ø¥Ø¶Ø§ÙØ© Tag "New" (20 Ø¯Ù‚ÙŠÙ‚Ø©)
4. ğŸ“ Ø§Ù„Ù…Ø±Ø­Ù„Ø© 4: Ù†Ø¸Ø§Ù… BlockUI (45 Ø¯Ù‚ÙŠÙ‚Ø©)
5. ğŸ“ Ø§Ù„Ù…Ø±Ø­Ù„Ø© 3: ØµÙØ­Ø© About (60 Ø¯Ù‚ÙŠÙ‚Ø©)
6. ğŸ“ Ø§Ù„Ù…Ø±Ø­Ù„Ø© 2: ØµÙØ­Ø© Profile (60 Ø¯Ù‚ÙŠÙ‚Ø©)
7. ğŸ“ Ø§Ù„Ù…Ø±Ø­Ù„Ø© 7: ØªØ­Ø³ÙŠÙ† UI Components (90 Ø¯Ù‚ÙŠÙ‚Ø©)
```

**Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…Ù‚Ø¯Ø±:** ~5 Ø³Ø§Ø¹Ø§Øª

---

## âœ… **Checklist Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ:**

### **Topbar:**
- [ ] ØªØ­Ø±ÙŠÙƒ Menu Toggle
- [ ] Avatar Ù…Ø¹ Label/Image
- [ ] Badge Ù„Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª
- [ ] Gravatar support

### **Sidebar:**
- [ ] Ø¥Ø¶Ø§ÙØ© Profile
- [ ] Ø¥Ø¶Ø§ÙØ© About
- [ ] Tag "New" Ø¹Ù„Ù‰ Ø§Ù„ØµÙØ­Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©

### **Protected Pages:**
- [ ] BlockUI Ø¹Ù„Ù‰ Campaigns
- [ ] BlockUI Ø¹Ù„Ù‰ Reports
- [ ] BlockUI Ø¹Ù„Ù‰ Interactive
- [ ] OTP Dialog
- [ ] Subscription check

### **Global:**
- [ ] ScrollTop component
- [ ] Unified theme colors
- [ ] LocalStorage integration

### **UI Components:**
- [ ] Badge page
- [ ] Tag page
- [ ] Chip page
- [ ] Avatar page

---

## **Ø§Ù„Ù…Ø±Ø­Ù„Ø© 6: Notification System** ğŸ”” âœ…

**Ø§Ù„Ù…ÙŠØ²Ø§Øª Ø§Ù„Ù…ÙƒØªÙ…Ù„Ø©:**
- âœ… Backend API (GET, POST, PATCH, DELETE, count)
- âœ… WebSocket real-time notifications
- âœ… Frontend Components (Bell, Dropdown, Item, Page)
- âœ… Mark as read (single/all), Delete, Filter, Pagination
- âœ… Auto-refresh (30s polling) + WebSocket fallback
- âœ… NotificationContext + Global state management

**Ø§Ù„Ù…Ù„ÙØ§Øª:**
- `/components/Notifications/` - NotificationBell, Dropdown, Item, Center
- `/app/(main)/notifications/page.tsx`
- `/api/notifications/` - route.ts, [id]/route.ts, count/route.ts
- `/contexts/NotificationContext.tsx`
- `/runtime/server/routes/notifications.js`

---

## **Ø§Ù„Ù…Ø±Ø­Ù„Ø© 8: Webhook Dispatcher** ğŸª âœ…

**Ø§Ù„Ù…ÙŠØ²Ø§Øª Ø§Ù„Ù…ÙƒØªÙ…Ù„Ø©:**
- âœ… HMAC SHA-256 Signature System (timing-safe)
- âœ… Webhook Manager (register, dispatch, retry, logs, stats)
- âœ… Event Integration (8 events: message_received, message_sent, campaign_executed, campaign_completed, client_connected, client_disconnected, smartbot_reply, session_qr)
- âœ… API Routes (CRUD, test, logs, statistics)
- âœ… Settings Page UI (create/edit/delete, event selection, secret generation, retry config)
- âœ… Retry mechanism with exponential backoff (3 attempts)

**Ø§Ù„Ù…Ù„ÙØ§Øª:**
- `/runtime/server/webhooks/` - WebhookManager.js, signature.js, eventIntegration.js
- `/runtime/server/routes/webhooks.js`
- `/app/(main)/settings/webhooks/page.tsx`

**Status**: ğŸ‰ Production Ready!

---

### **ğŸ“¡ Webhook Events:**

```typescript
type WebhookEvent = 
  | 'message_received'
  | 'message_sent'
  | 'campaign_executed'
  | 'campaign_completed'
  | 'client_connected'
  | 'client_disconnected'
  | 'smartbot_reply'
  | 'session_qr';

interface WebhookPayload {
  event: WebhookEvent;
  timestamp: string;
  data: any;
}
```

---

### **ğŸ”’ HMAC Signature (Security):**

#### **Server-Side (Signing):**

```typescript
// server/webhooks/signature.ts
import crypto from 'crypto';

export function generateSignature(payload: string, secret: string): string {
  const hmac = crypto.createHmac('sha256', secret);
  hmac.update(payload);
  return 'sha256=' + hmac.digest('hex');
}

export function verifySignature(
  payload: string,
  signature: string,
  secret: string
): boolean {
  const expectedSignature = generateSignature(payload, secret);
  return crypto.timingSafeEqual(
    Buffer.from(signature),
    Buffer.from(expectedSignature)
  );
}
```

#### **Client-Side (Verification):**

```typescript
// Your webhook endpoint
app.post('/webhooks/waqtor', (req, res) => {
  const signature = req.headers['x-waqtor-signature'];
  const rawBody = JSON.stringify(req.body);
  
  const secret = process.env.WEBHOOK_SECRET;
  const expectedSig = 'sha256=' + crypto
    .createHmac('sha256', secret)
    .update(rawBody)
    .digest('hex');
  
  if (signature !== expectedSig) {
    return res.status(401).json({ error: 'Invalid signature' });
  }
  
  // Process webhook
  console.log('Webhook received:', req.body);
  res.status(200).json({ received: true });
});
```

---

### **ğŸ”§ Backend Implementation:**

#### **1. Webhook Manager:**

```typescript
// server/webhooks/WebhookManager.ts
import axios from 'axios';
import { EventBus } from '@waqtor/core';
import { generateSignature } from './signature';

interface WebhookConfig {
  id: string;
  url: string;
  events: WebhookEvent[];
  secret: string;
  enabled: boolean;
  retryAttempts: number;
  retryDelay: number;
}

export class WebhookManager {
  private webhooks: Map<string, WebhookConfig> = new Map();
  private eventBus: EventBus;

  constructor(eventBus: EventBus) {
    this.eventBus = eventBus;
    this.setupEventListeners();
  }

  private setupEventListeners() {
    // Message received
    this.eventBus.on('message.received', (data) => {
      this.dispatch('message_received', data);
    });

    // Message sent
    this.eventBus.on('message.sent', (data) => {
      this.dispatch('message_sent', data);
    });

    // Campaign executed
    this.eventBus.on('campaign.progress', (data) => {
      this.dispatch('campaign_executed', data);
    });

    // Campaign completed
    this.eventBus.on('campaign.completed', (data) => {
      this.dispatch('campaign_completed', data);
    });

    // Client connected
    this.eventBus.on('session.status', (data) => {
      if (data.status === 'ready') {
        this.dispatch('client_connected', data);
      } else if (data.status === 'disconnected') {
        this.dispatch('client_disconnected', data);
      }
    });

    // SmartBot reply
    this.eventBus.on('smartbot.reply', (data) => {
      this.dispatch('smartbot_reply', data);
    });

    // Session QR
    this.eventBus.on('session.qr', (data) => {
      this.dispatch('session_qr', data);
    });
  }

  async dispatch(event: WebhookEvent, data: any) {
    const webhooks = Array.from(this.webhooks.values())
      .filter(wh => wh.enabled && wh.events.includes(event));

    for (const webhook of webhooks) {
      await this.sendWebhook(webhook, event, data);
    }
  }

  private async sendWebhook(
    webhook: WebhookConfig,
    event: WebhookEvent,
    data: any,
    attempt: number = 1
  ) {
    const payload: WebhookPayload = {
      event,
      timestamp: new Date().toISOString(),
      data
    };

    const rawBody = JSON.stringify(payload);
    const signature = generateSignature(rawBody, webhook.secret);

    try {
      const response = await axios.post(webhook.url, payload, {
        headers: {
          'Content-Type': 'application/json',
          'X-Waqtor-Signature': signature,
          'X-Waqtor-Event': event,
          'User-Agent': 'WaQtor-Webhook/2.2.0'
        },
        timeout: 10000
      });

      // Log success
      await this.logWebhook(webhook.id, event, 'success', response.status);
    } catch (error: any) {
      console.error(`Webhook failed (attempt ${attempt}):`, error.message);

      // Retry with exponential backoff
      if (attempt < webhook.retryAttempts) {
        const delay = webhook.retryDelay * Math.pow(2, attempt - 1);
        setTimeout(() => {
          this.sendWebhook(webhook, event, data, attempt + 1);
        }, delay);
      } else {
        // Log failure
        await this.logWebhook(webhook.id, event, 'failed', error.response?.status);
      }
    }
  }

  private async logWebhook(
    webhookId: string,
    event: string,
    status: 'success' | 'failed',
    statusCode?: number
  ) {
    // Save to database or file
    console.log(`Webhook Log: ${webhookId} - ${event} - ${status} - ${statusCode}`);
  }

  // CRUD operations
  addWebhook(config: WebhookConfig) {
    this.webhooks.set(config.id, config);
  }

  removeWebhook(id: string) {
    this.webhooks.delete(id);
  }

  updateWebhook(id: string, updates: Partial<WebhookConfig>) {
    const webhook = this.webhooks.get(id);
    if (webhook) {
      this.webhooks.set(id, { ...webhook, ...updates });
    }
  }

  getWebhook(id: string): WebhookConfig | undefined {
    return this.webhooks.get(id);
  }

  getAllWebhooks(): WebhookConfig[] {
    return Array.from(this.webhooks.values());
  }
}
```

#### **2. API Routes:**

```typescript
// server/api/webhooks.ts
import express from 'express';
import { WebhookManager } from '../webhooks/WebhookManager';

const router = express.Router();

// Get all webhooks
router.get('/webhooks', (req, res) => {
  const webhooks = webhookManager.getAllWebhooks();
  res.json({ webhooks });
});

// Create webhook
router.post('/webhooks', (req, res) => {
  const { url, events, secret } = req.body;
  
  const webhook = {
    id: generateId(),
    url,
    events,
    secret: secret || generateSecret(),
    enabled: true,
    retryAttempts: 3,
    retryDelay: 1000
  };
  
  webhookManager.addWebhook(webhook);
  res.status(201).json({ webhook });
});

// Update webhook
router.patch('/webhooks/:id', (req, res) => {
  const { id } = req.params;
  const updates = req.body;
  
  webhookManager.updateWebhook(id, updates);
  res.json({ success: true });
});

// Delete webhook
router.delete('/webhooks/:id', (req, res) => {
  const { id } = req.params;
  webhookManager.removeWebhook(id);
  res.json({ success: true });
});

// Test webhook
router.post('/webhooks/:id/test', async (req, res) => {
  const { id } = req.params;
  const webhook = webhookManager.getWebhook(id);
  
  if (!webhook) {
    return res.status(404).json({ error: 'Webhook not found' });
  }
  
  // Send test payload
  await webhookManager.dispatch('message_received', {
    from: 'test@c.us',
    body: 'Test message',
    timestamp: new Date().toISOString()
  });
  
  res.json({ success: true, message: 'Test webhook sent' });
});

export default router;
```

---

### **ğŸ’» Dashboard Implementation:**

#### **1. Webhook Settings Page:**

```typescript
// dashboard/src/app/(main)/settings/webhooks/page.tsx
'use client';

import { useState, useEffect } from 'react';
import { DataTable } from 'primereact/datatable';
import { Column } from 'primereact/column';
import { Button } from 'primereact/button';
import { Dialog } from 'primereact/dialog';
import { InputText } from 'primereact/inputtext';
import { MultiSelect } from 'primereact/multiselect';
import { InputSwitch } from 'primereact/inputswitch';
import { Card } from 'primereact/card';
import { Toast } from 'primereact/toast';
import axios from 'axios';

const WEBHOOK_EVENTS = [
  { label: 'Message Received', value: 'message_received' },
  { label: 'Message Sent', value: 'message_sent' },
  { label: 'Campaign Executed', value: 'campaign_executed' },
  { label: 'Campaign Completed', value: 'campaign_completed' },
  { label: 'Client Connected', value: 'client_connected' },
  { label: 'Client Disconnected', value: 'client_disconnected' },
  { label: 'SmartBot Reply', value: 'smartbot_reply' },
  { label: 'Session QR', value: 'session_qr' }
];

export default function WebhooksPage() {
  const [webhooks, setWebhooks] = useState([]);
  const [showDialog, setShowDialog] = useState(false);
  const [editingWebhook, setEditingWebhook] = useState(null);
  const [formData, setFormData] = useState({
    url: '',
    events: [],
    secret: '',
    enabled: true
  });

  useEffect(() => {
    loadWebhooks();
  }, []);

  const loadWebhooks = async () => {
    try {
      const response = await axios.get('/api/webhooks');
      setWebhooks(response.data.webhooks);
    } catch (error) {
      console.error('Failed to load webhooks:', error);
    }
  };

  const handleSave = async () => {
    try {
      if (editingWebhook) {
        await axios.patch(`/api/webhooks/${editingWebhook.id}`, formData);
      } else {
        await axios.post('/api/webhooks', formData);
      }
      
      setShowDialog(false);
      loadWebhooks();
      toast.current.show({
        severity: 'success',
        summary: 'Success',
        detail: 'Webhook saved successfully'
      });
    } catch (error) {
      console.error('Failed to save webhook:', error);
    }
  };

  const handleDelete = async (id: string) => {
    try {
      await axios.delete(`/api/webhooks/${id}`);
      loadWebhooks();
    } catch (error) {
      console.error('Failed to delete webhook:', error);
    }
  };

  const handleTest = async (id: string) => {
    try {
      await axios.post(`/api/webhooks/${id}/test`);
      toast.current.show({
        severity: 'info',
        summary: 'Test Sent',
        detail: 'Test webhook has been dispatched'
      });
    } catch (error) {
      console.error('Failed to test webhook:', error);
    }
  };

  const actionTemplate = (rowData: any) => {
    return (
      <div className="flex gap-2">
        <Button
          icon="pi pi-pencil"
          size="small"
          onClick={() => {
            setEditingWebhook(rowData);
            setFormData(rowData);
            setShowDialog(true);
          }}
        />
        <Button
          icon="pi pi-send"
          size="small"
          severity="info"
          onClick={() => handleTest(rowData.id)}
        />
        <Button
          icon="pi pi-trash"
          size="small"
          severity="danger"
          onClick={() => handleDelete(rowData.id)}
        />
      </div>
    );
  };

  return (
    <div className="grid">
      <div className="col-12">
        <Card title="Webhooks Management">
          <div className="mb-3">
            <Button
              label="Add Webhook"
              icon="pi pi-plus"
              onClick={() => {
                setEditingWebhook(null);
                setFormData({ url: '', events: [], secret: '', enabled: true });
                setShowDialog(true);
              }}
            />
          </div>

          <DataTable value={webhooks} paginator rows={10}>
            <Column field="url" header="URL" />
            <Column
              field="events"
              header="Events"
              body={(rowData) => rowData.events.join(', ')}
            />
            <Column
              field="enabled"
              header="Status"
              body={(rowData) => (
                <span className={`badge ${rowData.enabled ? 'badge-success' : 'badge-danger'}`}>
                  {rowData.enabled ? 'Enabled' : 'Disabled'}
                </span>
              )}
            />
            <Column header="Actions" body={actionTemplate} />
          </DataTable>
        </Card>
      </div>

      <Dialog
        visible={showDialog}
        onHide={() => setShowDialog(false)}
        header={editingWebhook ? 'Edit Webhook' : 'Add Webhook'}
        style={{ width: '600px' }}
      >
        <div className="flex flex-column gap-3">
          <div>
            <label>Webhook URL</label>
            <InputText
              value={formData.url}
              onChange={(e) => setFormData({ ...formData, url: e.target.value })}
              className="w-full"
              placeholder="https://yourapp.com/webhooks/waqtor"
            />
          </div>

          <div>
            <label>Events</label>
            <MultiSelect
              value={formData.events}
              onChange={(e) => setFormData({ ...formData, events: e.value })}
              options={WEBHOOK_EVENTS}
              className="w-full"
              placeholder="Select events"
            />
          </div>

          <div>
            <label>Secret Key</label>
            <InputText
              value={formData.secret}
              onChange={(e) => setFormData({ ...formData, secret: e.target.value })}
              className="w-full"
              placeholder="Leave empty to auto-generate"
            />
          </div>

          <div className="flex align-items-center gap-2">
            <label>Enabled</label>
            <InputSwitch
              checked={formData.enabled}
              onChange={(e) => setFormData({ ...formData, enabled: e.value })}
            />
          </div>

          <div className="flex justify-content-end gap-2">
            <Button label="Cancel" severity="secondary" onClick={() => setShowDialog(false)} />
            <Button label="Save" onClick={handleSave} />
          </div>
        </div>
      </Dialog>

      <Toast ref={toast} />
    </div>
  );
}
```

---

### **ğŸ“ Example Usage:**

#### **cURL Test:**

```bash
# Test webhook endpoint
curl -X POST https://yourapp.com/webhooks/waqtor \
  -H "X-Waqtor-Signature: sha256=abc123..." \
  -H "X-Waqtor-Event: message_received" \
  -H "Content-Type: application/json" \
  -d '{
    "event": "message_received",
    "timestamp": "2025-10-30T19:30:00Z",
    "data": {
      "from": "9715...@c.us",
      "body": "Hi",
      "messageId": "msg_123",
      "isGroup": false
    }
  }'
```

#### **Node.js Webhook Receiver:**

```javascript
const express = require('express');
const crypto = require('crypto');

const app = express();
app.use(express.json());

const WEBHOOK_SECRET = 'your_secret_here';

app.post('/webhooks/waqtor', (req, res) => {
  // Verify signature
  const signature = req.headers['x-waqtor-signature'];
  const rawBody = JSON.stringify(req.body);
  
  const expectedSig = 'sha256=' + crypto
    .createHmac('sha256', WEBHOOK_SECRET)
    .update(rawBody)
    .digest('hex');
  
  if (signature !== expectedSig) {
    return res.status(401).json({ error: 'Invalid signature' });
  }
  
  // Process webhook
  const { event, data } = req.body;
  
  switch (event) {
    case 'message_received':
      console.log('New message from:', data.from);
      console.log('Message body:', data.body);
      break;
      
    case 'campaign_completed':
      console.log('Campaign completed:', data.campaignId);
      console.log('Total sent:', data.totalSent);
      break;
      
    default:
      console.log('Unknown event:', event);
  }
  
  res.status(200).json({ received: true });
});

app.listen(3000, () => {
  console.log('Webhook receiver running on port 3000');
});
```

---

### **ğŸ“Š Webhook Logs & Monitoring:**

```typescript
// Dashboard component for webhook logs
interface WebhookLog {
  id: string;
  webhookId: string;
  event: string;
  status: 'success' | 'failed';
  statusCode: number;
  timestamp: Date;
  responseTime: number;
}

export function WebhookLogs() {
  const [logs, setLogs] = useState<WebhookLog[]>([]);

  return (
    <Card title="Webhook Logs">
      <DataTable value={logs} paginator rows={20}>
        <Column field="timestamp" header="Time" />
        <Column field="event" header="Event" />
        <Column field="status" header="Status" />
        <Column field="statusCode" header="Status Code" />
        <Column field="responseTime" header="Response Time (ms)" />
      </DataTable>
    </Card>
  );
}
```

---

### **ğŸ”§ Configuration (.env):**

```bash
# Webhook settings
WEBHOOK_SECRET=your_super_secret_key_here
WEBHOOK_RETRY_ATTEMPTS=3
WEBHOOK_RETRY_DELAY=1000
WEBHOOK_TIMEOUT=10000
```

---

### **ğŸ“ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©:**

```
ğŸ“ packages/server/src/webhooks/
â”œâ”€â”€ WebhookManager.ts          # Webhook dispatcher
â”œâ”€â”€ signature.ts               # HMAC signature utilities
â””â”€â”€ types.ts                   # TypeScript definitions

ğŸ“ packages/server/src/api/
â””â”€â”€ webhooks.ts                # Webhook CRUD API

ğŸ“ dashboard/src/app/(main)/settings/webhooks/
â”œâ”€â”€ page.tsx                   # Webhooks management page
â””â”€â”€ logs/
    â””â”€â”€ page.tsx               # Webhook logs page

ğŸ“ documentation/
â””â”€â”€ WEBHOOKS.md                # Webhook documentation
```

---

---

## ğŸ¤– **Ø§Ù„Ù…Ø±Ø­Ù„Ø© 9: SmartBot AI Engine v2** âœ…

**Ø§Ù„Ù…ÙŠØ²Ø§Øª Ø§Ù„Ù…ÙƒØªÙ…Ù„Ø©:**
- âœ… Semantic Matching (Embeddings: MiniLM/MPNet)
- âœ… Confidence scoring
- âœ… Template expansion Ù…Ø¹ Ù…ØªØºÙŠØ±Ø§Øª Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©
- âœ… Learning loop Ù…Ø¹ Ù…Ø±Ø§Ø¬Ø¹Ø© Ø¨Ø´Ø±ÙŠØ©
- âœ… Database Schema (smartbot_rules, smartbot_embeddings, smartbot_history, smartbot_suggestions)

**Ø§Ù„Ù…Ù„ÙØ§Øª:**
- `/runtime/server/ai/` - SemanticMatcher.js, EmbeddingService.js
- `/runtime/server/database/smartbot.db`

---

## ğŸ—ï¸ **Ø§Ù„Ù…Ø±Ø­Ù„Ø© 10: Architecture Evolution** âœ…

**Ø§Ù„Ù…ÙŠØ²Ø§Øª Ø§Ù„Ù…ÙƒØªÙ…Ù„Ø©:**
- âœ… Modular Microkernel Architecture
- âœ… Backward Compatibility
- âœ… Plugin System
- âœ… Event-driven Architecture

**Ø§Ù„Ù…Ù„ÙØ§Øª:**
- `/runtime/server/core/` - EventBus.js, PluginManager.js

---

---
- Ø¥Ø±Ø³Ø§Ù„/Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„
- Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø­Ù…Ù„Ø§Øª (Campaign Engine)
- Storage abstraction

// âŒ Ù„Ø§ ÙŠØ¹Ø±Ù Ø´ÙŠØ¦Ø§Ù‹ Ø¹Ù†:
- Express.js
- Next.js
- HTTP/REST
- WebSocket
- UI/Frontend
```

#### **2. @waqtor/server** (Ø·Ø¨Ù‚Ø© Ø§Ù„Ù€ API)
```typescript
// âœ… Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„ÙŠØ§Øª:
- REST API endpoints
- WebSocket server
- Webhooks
- Authentication & Authorization
- Rate limiting
- CORS handling

// âŒ Ù„Ø§ ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰:
- UI components
- Frontend logic
- Direct WhatsApp logic (ÙŠØ³ØªÙ‡Ù„Ùƒ core ÙÙ‚Ø·)
```

#### **3. Dashboard** (Ø§Ù„ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø£Ù…Ø§Ù…ÙŠØ©)
```typescript
// âœ… Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„ÙŠØ§Øª:
- UI/UX
- User interactions
- Data visualization
- Real-time updates

// âŒ Ù„Ø§ ÙŠØ¹Ø±Ù Ø´ÙŠØ¦Ø§Ù‹ Ø¹Ù†:
- WhatsApp internals
- Puppeteer
- Session management
- (ÙŠØ³ØªÙ‡Ù„Ùƒ REST/WS ÙÙ‚Ø·)
```

---

### **ğŸ“¡ ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø£Ø­Ø¯Ø§Ø« ÙˆØ§Ù„Ø£ÙˆØ§Ù…Ø± (Contracts):**

#### **Events** (ÙŠÙØ¨Ø«Ù‘Ù‡Ø§ `@waqtor/core`):
```typescript
type CoreEvents =
  | { 
      type: 'session.qr'; 
      data: { qr: string; timestamp: string } 
    }
  | { 
      type: 'session.status'; 
      data: { 
        status: 'ready' | 'disconnected' | 'auth_failure' | 'connecting'; 
        timestamp: string;
        clientInfo?: {
          platform: string;
          phoneNumber: string;
          name: string;
        }
      } 
    }
  | { 
      type: 'message.received'; 
      data: { 
        from: string; 
        body: string; 
        timestamp: string;
        messageId: string;
        isGroup: boolean;
      } 
    }
  | { 
      type: 'message.sent'; 
      data: { 
        to: string; 
        messageId: string; 
        timestamp: string;
        status: 'pending' | 'sent' | 'delivered' | 'read' | 'failed';
      } 
    }
  | { 
      type: 'campaign.progress'; 
      data: { 
        campaignId: string; 
        sent: number; 
        total: number; 
        failed: number;
        status: 'running' | 'paused' | 'completed' | 'failed';
      } 
    }
  | {
      type: 'smartbot.reply';
      data: {
        to: string;
        trigger: string;
        response: string;
        timestamp: string;
      }
    };
```

#### **Commands** (ÙŠØ³ØªÙ‚Ø¨Ù„Ù‡Ø§ `@waqtor/core`):
```typescript
interface CoreCommands {
  // Message Commands
  sendText(params: {
    chatId: string;
    text: string;
    options?: {
      quotedMessageId?: string;
      mentionedIds?: string[];
    };
  }): Promise<{ messageId: string; timestamp: string }>;

  sendMedia(params: {
    chatId: string;
    media: string | Buffer;
    type: 'image' | 'video' | 'audio' | 'document';
    caption?: string;
    filename?: string;
  }): Promise<{ messageId: string; timestamp: string }>;

  // Campaign Commands
  createCampaign(params: {
    name: string;
    recipients: string[];
    template: string;
    variables?: Record<string, any>;
    scheduleAt?: Date;
  }): Promise<{ campaignId: string }>;

  controlCampaign(params: {
    campaignId: string;
    action: 'pause' | 'resume' | 'cancel';
  }): Promise<{ status: string }>;

  // Session Commands
  getSessionState(): Promise<{
    status: 'ready' | 'disconnected' | 'connecting';
    clientInfo?: ClientInfo;
  }>;

  logout(): Promise<void>;
  
  restartSession(): Promise<void>;
}
```

---

### **ğŸ”Œ Plugin System (Ø§Ø®ØªÙŠØ§Ø±ÙŠ):**

```typescript
// @waqtor/core/src/plugins/interface.ts
interface WaqtorPlugin {
  name: string;
  version: string;
  
  // Lifecycle hooks
  onLoad?(core: WaqtorCore): void;
  onMessage?(message: Message): void | Promise<void>;
  onSessionChange?(status: SessionStatus): void;
  
  // Custom commands
  commands?: Record<string, PluginCommand>;
}

// Example: SmartBot Plugin
class SmartBotPlugin implements WaqtorPlugin {
  name = 'smartbot';
  version = '1.0.0';
  
  async onMessage(message: Message) {
    const reply = await this.matchRule(message.body);
    if (reply) {
      await message.reply(reply);
    }
  }
  
  private async matchRule(text: string): Promise<string | null> {
    // Smart matching logic
  }
}
```

---

### **ğŸ“š SDK Examples:**

#### **Node.js SDK (@waqtor/sdk):**
```typescript
import { WaqtorClient } from '@waqtor/sdk';

const client = new WaqtorClient({
  apiUrl: 'http://localhost:8080',
  apiKey: 'your_api_key_here'
});

// Send message
await client.messages.send({
  to: '966501234567@c.us',
  text: 'Hello from Waqtor SDK!'
});

// Listen to events
client.on('message.received', (data) => {
  console.log('New message:', data);
});

// Create campaign
const campaign = await client.campaigns.create({
  name: 'New Year Sale',
  recipients: ['966501234567@c.us', '966501234568@c.us'],
  template: 'Happy New Year! Get {{discount}}% off!',
  variables: { discount: 50 }
});
```

#### **Python SDK (waqtor):**
```python
from waqtor import WaqtorClient

client = WaqtorClient(
    api_url='http://localhost:8080',
    api_key='your_api_key_here'
)

# Send message
client.messages.send(
    to='966501234567@c.us',
    text='Hello from Waqtor Python SDK!'
)

# Listen to events
@client.on('message.received')
def on_message(data):
    print(f"New message: {data}")

# Create campaign
campaign = client.campaigns.create(
    name='New Year Sale',
    recipients=['966501234567@c.us', '966501234568@c.us'],
    template='Happy New Year! Get {{discount}}% off!',
    variables={'discount': 50}
)
```

---

### **ğŸ”„ Migration Path (Ø®Ø·Ø© Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„):**

#### **Phase 1: Refactor Core** (4-6 Ø£Ø³Ø§Ø¨ÙŠØ¹)
- [ ] Ø§Ø³ØªØ®Ø±Ø§Ø¬ `@waqtor/core` Ù…Ù† Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø­Ø§Ù„ÙŠ
- [ ] ØªØ·Ø¨ÙŠÙ‚ EventBus pattern
- [ ] ØªØ¹Ø±ÙŠÙ Contracts (Events + Commands)
- [ ] Unit tests Ù„Ù„Ù€ core
- [ ] Documentation

#### **Phase 2: Isolate Server** (2-3 Ø£Ø³Ø§Ø¨ÙŠØ¹)
- [ ] Ù†Ù‚Ù„ REST API Ø¥Ù„Ù‰ `@waqtor/server`
- [ ] Dependency Injection Ù„Ù„Ù€ core
- [ ] WebSocket refactoring
- [ ] Integration tests
- [ ] API versioning (v1, v2)

#### **Phase 3: Build SDKs** (3-4 Ø£Ø³Ø§Ø¨ÙŠØ¹)
- [ ] ØªØ·ÙˆÙŠØ± `@waqtor/sdk` (Node.js)
- [ ] ØªØ·ÙˆÙŠØ± `waqtor` (Python)
- [ ] TypeScript definitions
- [ ] SDK documentation
- [ ] Example projects

#### **Phase 4: Dashboard Migration** (1-2 Ø£Ø³Ø§Ø¨ÙŠØ¹)
- [ ] Ø§Ø³ØªØ®Ø¯Ø§Ù… SDK Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Axios Ù…Ø¨Ø§Ø´Ø±Ø©
- [ ] ØªØ­Ø¯ÙŠØ« WebSocket client
- [ ] Testing & validation
- [ ] Performance optimization

#### **Phase 5: Multi-Instance Support** (2-3 Ø£Ø³Ø§Ø¨ÙŠØ¹)
- [ ] Instance Manager
- [ ] Database per instance
- [ ] Load balancing
- [ ] Monitoring & health checks

---

### **ğŸ“Š Benefits (Ø§Ù„ÙÙˆØ§Ø¦Ø¯):**

#### **1. Maintainability (Ø³Ù‡ÙˆÙ„Ø© Ø§Ù„ØµÙŠØ§Ù†Ø©)**
- âœ… ÙƒÙ„ package Ù„Ù‡ Ù…Ø³Ø¤ÙˆÙ„ÙŠØ© ÙˆØ§Ø­Ø¯Ø©
- âœ… ØªØ­Ø¯ÙŠØ«Ø§Øª Ù…Ø¹Ø²ÙˆÙ„Ø© (update core Ø¨Ø¯ÙˆÙ† ØªØ£Ø«ÙŠØ± Ø¹Ù„Ù‰ server)
- âœ… Testing Ø£Ø³Ù‡Ù„ (unit tests per package)

#### **2. Scalability (Ù‚Ø§Ø¨Ù„ÙŠØ© Ø§Ù„ØªÙˆØ³Ø¹)**
- âœ… Multi-instance support
- âœ… Horizontal scaling
- âœ… Plugin system Ù„Ù„Ù…ÙŠØ²Ø§Øª Ø§Ù„Ø¥Ø¶Ø§ÙÙŠØ©

#### **3. Developer Experience**
- âœ… SDK Ø±Ø³Ù…ÙŠ Ù„Ù„Ù…Ø·ÙˆØ±ÙŠÙ†
- âœ… TypeScript support ÙƒØ§Ù…Ù„
- âœ… Documentation ÙˆØ§Ø¶Ø­Ø©
- âœ… Examples Ø¬Ø§Ù‡Ø²Ø©

#### **4. Backward Compatibility**
- âœ… Ø§Ù„Ù€ API Ø§Ù„Ø­Ø§Ù„ÙŠ ÙŠØ¨Ù‚Ù‰ ÙƒÙ…Ø§ Ù‡Ùˆ
- âœ… Dashboard ÙŠØ¹Ù…Ù„ Ø¨Ø¯ÙˆÙ† ØªØºÙŠÙŠØ±Ø§Øª
- âœ… Migration ØªØ¯Ø±ÙŠØ¬ÙŠØ© (phased approach)

---

### **ğŸ§ª Testing Strategy:**

```typescript
// @waqtor/core tests
describe('SessionManager', () => {
  it('should emit qr event on initialization', async () => {
    const manager = new SessionManager();
    const qrPromise = new Promise(resolve => {
      manager.on('session.qr', resolve);
    });
    
    await manager.initialize();
    const qrData = await qrPromise;
    
    expect(qrData).toHaveProperty('qr');
  });
});

// @waqtor/server tests
describe('POST /api/messages/send-text', () => {
  it('should send message and return messageId', async () => {
    const response = await request(app)
      .post('/api/messages/send-text')
      .set('X-API-Key', 'test_key')
      .send({
        chatId: '966501234567@c.us',
        text: 'Test message'
      });
    
    expect(response.status).toBe(200);
    expect(response.body).toHaveProperty('messageId');
  });
});

// @waqtor/sdk tests
describe('WaqtorClient', () => {
  it('should send message via SDK', async () => {
    const client = new WaqtorClient({ apiKey: 'test' });
    const result = await client.messages.send({
      to: '966501234567@c.us',
      text: 'SDK test'
    });
    
    expect(result).toHaveProperty('messageId');
  });
});
```

---

### **ğŸ“ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©:**

```
ğŸ“ packages/core/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ engine/
â”‚   â”‚   â”œâ”€â”€ WhatsAppClient.ts
â”‚   â”‚   â”œâ”€â”€ SessionManager.ts
â”‚   â”‚   â””â”€â”€ EventBus.ts
â”‚   â”œâ”€â”€ campaigns/
â”‚   â”‚   â”œâ”€â”€ CampaignEngine.ts
â”‚   â”‚   â””â”€â”€ CampaignScheduler.ts
â”‚   â”œâ”€â”€ storage/
â”‚   â”‚   â”œâ”€â”€ StorageAdapter.ts
â”‚   â”‚   â”œâ”€â”€ SQLiteAdapter.ts
â”‚   â”‚   â””â”€â”€ MemoryAdapter.ts
â”‚   â”œâ”€â”€ plugins/
â”‚   â”‚   â”œâ”€â”€ PluginInterface.ts
â”‚   â”‚   â””â”€â”€ PluginManager.ts
â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â”œâ”€â”€ events.ts
â”‚   â”‚   â””â”€â”€ commands.ts
â”‚   â””â”€â”€ index.ts
â”œâ”€â”€ tests/
â”œâ”€â”€ package.json
â””â”€â”€ README.md

ğŸ“ packages/server/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”œâ”€â”€ messages.ts
â”‚   â”‚   â”œâ”€â”€ campaigns.ts
â”‚   â”‚   â”œâ”€â”€ status.ts
â”‚   â”‚   â””â”€â”€ webhooks.ts
â”‚   â”œâ”€â”€ ws/
â”‚   â”‚   â””â”€â”€ websocket.ts
â”‚   â”œâ”€â”€ middleware/
â”‚   â”‚   â”œâ”€â”€ auth.ts
â”‚   â”‚   â”œâ”€â”€ rateLimit.ts
â”‚   â”‚   â””â”€â”€ cors.ts
â”‚   â”œâ”€â”€ bootstrap.ts
â”‚   â””â”€â”€ index.ts
â”œâ”€â”€ tests/
â”œâ”€â”€ package.json
â””â”€â”€ README.md

ğŸ“ packages/sdk-node/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ client.ts
â”‚   â”œâ”€â”€ resources/
â”‚   â”‚   â”œâ”€â”€ messages.ts
â”‚   â”‚   â”œâ”€â”€ campaigns.ts
â”‚   â”‚   â””â”€â”€ status.ts
â”‚   â”œâ”€â”€ types.ts
â”‚   â””â”€â”€ index.ts
â”œâ”€â”€ tests/
â”œâ”€â”€ examples/
â”œâ”€â”€ package.json
â””â”€â”€ README.md

ğŸ“ packages/sdk-py/
â”œâ”€â”€ waqtor/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ client.py
â”‚   â”œâ”€â”€ resources/
â”‚   â”‚   â”œâ”€â”€ messages.py
â”‚   â”‚   â”œâ”€â”€ campaigns.py
â”‚   â”‚   â””â”€â”€ status.py
â”‚   â””â”€â”€ types.py
â”œâ”€â”€ tests/
â”œâ”€â”€ examples/
â”œâ”€â”€ setup.py
â””â”€â”€ README.md
```

---

### **â±ï¸ Timeline (Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø²Ù…Ù†ÙŠ):**

| Phase | Duration | Deliverables |
|-------|----------|--------------|
| **Phase 1** | 4-6 weeks | `@waqtor/core` package |
| **Phase 2** | 2-3 weeks | `@waqtor/server` package |
| **Phase 3** | 3-4 weeks | SDKs (Node + Python) |
| **Phase 4** | 1-2 weeks | Dashboard migration |
| **Phase 5** | 2-3 weeks | Multi-instance support |
| **Total** | **12-18 weeks** | Full modular architecture |

---

### **ğŸ¯ Success Metrics:**

- âœ… **Code Coverage**: > 80% for all packages
- âœ… **API Compatibility**: 100% backward compatible
- âœ… **Performance**: No regression in response times
- âœ… **Bundle Size**: Core < 500KB, SDK < 100KB
- âœ… **Documentation**: 100% API coverage
- âœ… **Developer Adoption**: 10+ community projects using SDK

---

## ğŸ—ºï¸ **Ø®Ø·Ø© Ø§Ù„ØªÙ†ÙÙŠØ° Ø§Ù„Ø¹Ù…Ù„ÙŠØ© (Incremental Roadmap)**

### **Phase A: Ø§Ù„ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…Ø¹Ù…Ø§Ø±ÙŠØ© (4-6 Ø£Ø³Ø§Ø¨ÙŠØ¹)**

#### **Ø§Ù„Ø£Ù‡Ø¯Ø§Ù:**
- âœ… Ø¥Ù†Ø´Ø§Ø¡ `packages/core` Ù…Ø¹ Events/Commands ÙƒÙˆØ§Ø¬Ù‡Ø§Øª Ø±Ø³Ù…ÙŠØ©
- âœ… Ù†Ù‚Ù„ WhatsAppClient/SessionManager Ø¥Ù„Ù‰ core
- âœ… Ø¬Ø¹Ù„ server ÙŠØ­Ù‚Ù† core Ø¹Ø¨Ø± DI

#### **Ø§Ù„Ù…Ù‡Ø§Ù…:**

**Week 1-2: Core Package Setup**
- [ ] Ø¥Ù†Ø´Ø§Ø¡ `packages/core` directory structure
- [ ] ØªØ¹Ø±ÙŠÙ Event interfaces (`session.qr`, `message.received`, etc.)
- [ ] ØªØ¹Ø±ÙŠÙ Command interfaces (`sendText`, `createCampaign`, etc.)
- [ ] Ø¥Ù†Ø´Ø§Ø¡ EventBus class
- [ ] Unit tests Ù„Ù„Ù€ EventBus

**Week 3-4: Migration**
- [ ] Ù†Ù‚Ù„ WhatsAppClient Ù…Ù† `runtime/server` Ø¥Ù„Ù‰ `packages/core`
- [ ] Ù†Ù‚Ù„ SessionManager Ø¥Ù„Ù‰ core
- [ ] ØªØ­Ø¯ÙŠØ« imports ÙÙŠ server
- [ ] Integration tests

**Week 5-6: Dependency Injection**
- [ ] Ø¥Ù†Ø´Ø§Ø¡ `bootstrap.ts` ÙÙŠ server
- [ ] ØªØ·Ø¨ÙŠÙ‚ DI pattern
- [ ] Refactor server routes Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… injected core
- [ ] Documentation update

**Deliverables:**
```
packages/core/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ engine/
â”‚   â”‚   â”œâ”€â”€ WhatsAppClient.ts
â”‚   â”‚   â”œâ”€â”€ SessionManager.ts
â”‚   â”‚   â””â”€â”€ EventBus.ts
â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â”œâ”€â”€ events.ts
â”‚   â”‚   â””â”€â”€ commands.ts
â”‚   â””â”€â”€ index.ts
â””â”€â”€ package.json

packages/server/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ bootstrap.ts          # DI setup
â”‚   â””â”€â”€ index.ts
```

---

### **Phase B: WebSocket 2.0 (2-3 Ø£Ø³Ø§Ø¨ÙŠØ¹)**

#### **Ø§Ù„Ø£Ù‡Ø¯Ø§Ù:**
- âœ… ØªÙ†ÙÙŠØ° Namespaces (`/status`, `/campaigns`, `/smartbot`)
- âœ… Heartbeat + Auto-reconnect + Backpressure
- âœ… ØªØ­Ø¯ÙŠØ« Dashboard hooks

#### **Ø§Ù„Ù…Ù‡Ø§Ù…:**

**Week 1: Server Implementation**
- [ ] Ø¥Ù†Ø´Ø§Ø¡ `packages/server/src/ws/` directory
- [ ] ØªØ·Ø¨ÙŠÙ‚ `/status` namespace
- [ ] ØªØ·Ø¨ÙŠÙ‚ `/campaigns` namespace Ù…Ø¹ backpressure
- [ ] ØªØ·Ø¨ÙŠÙ‚ `/smartbot` namespace
- [ ] Heartbeat mechanism (ping/pong every 15s)
- [ ] WebSocket authentication middleware

**Week 2: Client Implementation**
- [ ] Ø¥Ù†Ø´Ø§Ø¡ `useWebSocket` base hook
- [ ] Ø¥Ù†Ø´Ø§Ø¡ `useStatusWebSocket` hook
- [ ] Ø¥Ù†Ø´Ø§Ø¡ `useCampaignsWebSocket` hook
- [ ] Ø¥Ù†Ø´Ø§Ø¡ `useSmartBotWebSocket` hook
- [ ] Auto-reconnect Ù…Ø¹ exponential backoff

**Week 3: Testing & Integration**
- [ ] WebSocket connection tests
- [ ] Namespace isolation tests
- [ ] Backpressure tests
- [ ] Dashboard integration
- [ ] Performance testing

**Deliverables:**
```
packages/server/src/ws/
â”œâ”€â”€ index.ts
â”œâ”€â”€ namespaces/
â”‚   â”œâ”€â”€ status.ts
â”‚   â”œâ”€â”€ campaigns.ts
â”‚   â””â”€â”€ smartbot.ts
â””â”€â”€ utils/
    â”œâ”€â”€ backpressure.ts
    â””â”€â”€ heartbeat.ts

dashboard/src/hooks/
â”œâ”€â”€ useWebSocket.ts
â”œâ”€â”€ useStatusWebSocket.ts
â”œâ”€â”€ useCampaignsWebSocket.ts
â””â”€â”€ useSmartBotWebSocket.ts
```

---

### **Phase C: Webhooks (2-3 Ø£Ø³Ø§Ø¨ÙŠØ¹)**

#### **Ø§Ù„Ø£Ù‡Ø¯Ø§Ù:**
- âœ… Ù…Ø³Ø§Ø± `/api/webhooks/*` Ù…Ø¹ HMAC signature
- âœ… Ù†Ù…ÙˆØ°Ø¬ Ø¥Ø¯Ø§Ø±Ø© Webhooks ÙÙŠ Settings
- âœ… Test delivery + logs

#### **Ø§Ù„Ù…Ù‡Ø§Ù…:**

**Week 1: Backend**
- [ ] Ø¥Ù†Ø´Ø§Ø¡ WebhookManager class
- [ ] ØªØ·Ø¨ÙŠÙ‚ HMAC signature (sha256)
- [ ] API routes (CRUD + test)
- [ ] Retry mechanism Ù…Ø¹ exponential backoff
- [ ] Webhook logging

**Week 2: Dashboard**
- [ ] ØµÙØ­Ø© Webhooks management
- [ ] Add/Edit/Delete webhooks
- [ ] Test webhook button
- [ ] Webhook logs viewer
- [ ] MultiSelect Ù„Ù„Ø£Ø­Ø¯Ø§Ø«

**Week 3: Testing & Documentation**
- [ ] Integration tests
- [ ] cURL examples
- [ ] Node.js receiver example
- [ ] Python receiver example
- [ ] WEBHOOKS.md documentation

**Deliverables:**
```
packages/server/src/webhooks/
â”œâ”€â”€ WebhookManager.ts
â”œâ”€â”€ signature.ts
â””â”€â”€ types.ts

packages/server/src/api/
â””â”€â”€ webhooks.ts

dashboard/src/app/(main)/settings/webhooks/
â”œâ”€â”€ page.tsx
â””â”€â”€ logs/page.tsx

documentation/
â””â”€â”€ WEBHOOKS.md
```

---

### **Phase D: SmartBot v2 (3-4 Ø£Ø³Ø§Ø¨ÙŠØ¹)**

#### **Ø§Ù„Ø£Ù‡Ø¯Ø§Ù:**
- âœ… Ø·Ø¨Ù‚Ø© Embeddings + ØªØ®Ø²ÙŠÙ† Ù…ØªØ¬Ù‡ÙŠ
- âœ… Migration Ù„Ø¬Ø¯Ø§ÙˆÙ„ embeddings/history
- âœ… Test Bench ÙÙŠ Ø§Ù„ÙˆØ§Ø¬Ù‡Ø©

#### **Ø§Ù„Ù…Ù‡Ø§Ù…:**

**Week 1: Embedding Service**
- [ ] ØªØ«Ø¨ÙŠØª `@xenova/transformers`
- [ ] Ø¥Ù†Ø´Ø§Ø¡ EmbeddingService class
- [ ] ØªØ·Ø¨ÙŠÙ‚ cosine similarity
- [ ] Benchmark performance

**Week 2: Database Migration**
- [ ] Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ø¯Ø§ÙˆÙ„ Ø¬Ø¯ÙŠØ¯Ø© (embeddings, history, suggestions)
- [ ] Migration script Ù…Ù† JSON Ø¥Ù„Ù‰ SQLite
- [ ] Data validation

**Week 3: SmartBot Engine v2**
- [ ] ØªØ·Ø¨ÙŠÙ‚ Pipeline (8 steps)
- [ ] TemplateEngine class
- [ ] SafetyLayer class
- [ ] Integration Ù…Ø¹ EventBus

**Week 4: Dashboard**
- [ ] Enhanced rule management
- [ ] "Generate Embedding" button
- [ ] Test Bench (Top-3 matches + confidence)
- [ ] Auto-Improve suggestions page

**Deliverables:**
```
packages/server/src/smartbot/
â”œâ”€â”€ EmbeddingService.ts
â”œâ”€â”€ SmartBotEngineV2.ts
â”œâ”€â”€ TemplateEngine.ts
â”œâ”€â”€ SafetyLayer.ts
â””â”€â”€ LanguageDetector.ts

database/migrations/
â””â”€â”€ 003_smartbot_v2.sql

dashboard/src/app/(main)/smartbot/
â”œâ”€â”€ page.tsx (enhanced)
â””â”€â”€ suggestions/
    â””â”€â”€ page.tsx
```

---

### **Phase E: SDK (3-4 Ø£Ø³Ø§Ø¨ÙŠØ¹)**

#### **Ø§Ù„Ø£Ù‡Ø¯Ø§Ù:**
- âœ… `@waqtor/sdk` (Node.js) ÙŠØºÙ„Ù REST/WS/Webhooks
- âœ… Python SDK Ø¨Ù†ÙØ³ Ø§Ù„Ø¹Ù‚ÙˆØ¯

#### **Ø§Ù„Ù…Ù‡Ø§Ù…:**

**Week 1-2: Node.js SDK**
- [ ] Ø¥Ù†Ø´Ø§Ø¡ `packages/sdk-node`
- [ ] WaqtorClient class
- [ ] Resources (messages, campaigns, status)
- [ ] WebSocket client wrapper
- [ ] TypeScript definitions
- [ ] Unit tests

**Week 3: Python SDK**
- [ ] Ø¥Ù†Ø´Ø§Ø¡ `packages/sdk-py`
- [ ] WaqtorClient class (Python)
- [ ] Resources implementation
- [ ] Type hints
- [ ] Unit tests

**Week 4: Documentation & Examples**
- [ ] SDK documentation
- [ ] Example projects (basic-bot, campaign-scheduler)
- [ ] API reference
- [ ] Publish to npm/PyPI

**Deliverables:**
```
packages/sdk-node/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ client.ts
â”‚   â”œâ”€â”€ resources/
â”‚   â”‚   â”œâ”€â”€ messages.ts
â”‚   â”‚   â”œâ”€â”€ campaigns.ts
â”‚   â”‚   â””â”€â”€ status.ts
â”‚   â””â”€â”€ index.ts
â”œâ”€â”€ examples/
â””â”€â”€ README.md

packages/sdk-py/
â”œâ”€â”€ waqtor/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ client.py
â”‚   â””â”€â”€ resources/
â”œâ”€â”€ examples/
â””â”€â”€ README.md
```

---

## ğŸ“Š **Timeline Summary:**

| Phase | Duration | Start | End | Status |
|-------|----------|-------|-----|--------|
| **Phase A** | 4-6 weeks | Week 1 | Week 6 | ğŸ”µ Planned |
| **Phase B** | 2-3 weeks | Week 7 | Week 9 | ğŸ”µ Planned |
| **Phase C** | 2-3 weeks | Week 10 | Week 12 | ğŸ”µ Planned |
| **Phase D** | 3-4 weeks | Week 13 | Week 16 | ğŸ”µ Planned |
| **Phase E** | 3-4 weeks | Week 17 | Week 20 | ğŸ”µ Planned |
| **Total** | **14-20 weeks** | - | - | **~4-5 months** |

---

## ğŸ“ **Design Contracts (Ù„Ù„Ù€ README Ø§Ù„Ø¹Ø§Ù…)**

### **Event Names:**

```typescript
// Session Events
- 'session.qr'              // QR code generated
- 'session.status'          // Status changed (ready/disconnected/connecting)
- 'session.stats'           // Statistics updated

// Message Events
- 'message.received'        // Incoming message
- 'message.sent'            // Outgoing message sent
- 'message.delivered'       // Message delivered
- 'message.read'            // Message read

// Campaign Events
- 'campaign.progress'       // Campaign execution progress
- 'campaign.completed'      // Campaign finished
- 'campaign.paused'         // Campaign paused
- 'campaign.failed'         // Campaign failed

// SmartBot Events
- 'smartbot.reply'          // Auto-reply sent
- 'smartbot.rule-updated'   // Rule created/updated/deleted
```

### **REST â†’ Commands:**

```typescript
// Message Commands
POST /api/messages/send-text
POST /api/messages/send-media
POST /api/messages/send-button
POST /api/messages/send-list

// Campaign Commands
POST /api/campaigns/create
POST /api/campaigns/:id/execute
POST /api/campaigns/:id/pause
POST /api/campaigns/:id/resume
POST /api/campaigns/:id/cancel
GET  /api/campaigns/:id/status

// Session Commands
GET  /api/session/state
POST /api/session/logout
POST /api/session/restart

// SmartBot Commands
GET  /api/smartbot/rules
POST /api/smartbot/rules
PUT  /api/smartbot/rules/:id
DELETE /api/smartbot/rules/:id
POST /api/smartbot/test

// Webhook Commands
GET  /api/webhooks
POST /api/webhooks
PATCH /api/webhooks/:id
DELETE /api/webhooks/:id
POST /api/webhooks/:id/test
```

---

## ğŸ”„ **Data Flow (Ù„Ù„Ù€ README Ø§Ù„Ø®Ø§Øµ Ø¨Ø§Ù„Ù€ Dashboard)**

### **WebSocket Data Flow:**

```
Backend Events
    â†“
WebSocket Namespaces
    â”œâ”€ /status    â†’ session.qr, session.status, session.stats
    â”œâ”€ /campaigns â†’ campaign.progress, campaign.completed
    â””â”€ /smartbot  â†’ message.received, smartbot.reply
    â†“
Dashboard Hooks
    â”œâ”€ useStatusWebSocket()
    â”œâ”€ useCampaignsWebSocket()
    â””â”€ useSmartBotWebSocket()
    â†“
Zustand Store
    â”œâ”€ setQrCode()
    â”œâ”€ setSessionStatus()
    â”œâ”€ updateCampaignProgress()
    â””â”€ addSmartBotReply()
    â†“
React Components
    â”œâ”€ QRStatusCard
    â”œâ”€ SessionStatsCard
    â”œâ”€ CampaignList
    â””â”€ SmartBotHistory
```

### **REST Data Flow:**

```
User Action
    â†“
React Component
    â†“
React Query Mutation
    â”œâ”€ useMutation('sendMessage')
    â”œâ”€ useMutation('createCampaign')
    â””â”€ useMutation('executeCommand')
    â†“
REST API
    â”œâ”€ POST /api/messages/send-text
    â”œâ”€ POST /api/campaigns/create
    â””â”€ POST /api/campaigns/:id/execute
    â†“
Backend Processing
    â†“
Event Emitted
    â†“
WebSocket Broadcast
    â†“
Dashboard Update (real-time)
```

### **Cache Strategy:**

```typescript
// React Query Cache
- Stale Time: 30 seconds (most queries)
- Cache Time: 5 minutes
- Retry: 3 attempts with exponential backoff
- Refetch on Window Focus: Enabled for critical data

// Zustand Store (UI State)
- Theme, scale, sidebar visibility
- Branding (logo, app name, footer)
- Persisted to localStorage

// WebSocket (Real-time)
- In-memory cache
- No persistence
- Auto-reconnect on disconnect
```

---

## ğŸ”§ **Ø§Ù„Ù…Ø±Ø­Ù„Ø© 9ï¸âƒ£: WebSocket & Notification Enhancements** ğŸ“Š **PLANNED**

### **ğŸ¯ Ø§Ù„Ø£Ù‡Ø¯Ø§Ù:**
- ğŸ—„ï¸ Ù†Ù‚Ù„ Notifications Ù…Ù† In-Memory Ø¥Ù„Ù‰ Database
- ğŸ›¡ï¸ Ø¥Ø¶Ø§ÙØ© Rate Limiting Ù„Ù„Ù€ WebSocket
- ğŸ“¦ Ø¥Ø¶Ø§ÙØ© Compression Ù„Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„ÙƒØ¨ÙŠØ±Ø©
- ğŸ’“ Heartbeat Ù‚ÙˆÙŠ ÙˆØ¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ø§ØªØµØ§Ù„Ø§Øª Ø§Ù„Ù…ÙŠØªØ©
- ğŸ›¡ï¸ Backpressure ÙˆØ­Ù…Ø§ÙŠØ© Ø§Ù„Ø°Ø§ÙƒØ±Ø©

---

### **ğŸ“‹ Ø§Ù„Ù…Ù‡Ø§Ù…:**

#### **0. ØªØ­Ø³ÙŠÙ†Ø§Øª Native WebSocket (ws)** ğŸš€

**Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©:**
```javascript
// /runtime/server/services/websocketBridge.js
// WebSocket Ø¨Ø¯ÙˆÙ† heartbeat Ù‚ÙˆÙŠ Ø£Ùˆ backpressure
```

**Ø§Ù„Ù…Ø·Ù„ÙˆØ¨:**
- âœ… Heartbeat Ù‚ÙˆÙŠ Ù…Ø¹ ping/pong
- âœ… Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ø§ØªØµØ§Ù„Ø§Øª Ø§Ù„Ù…ÙŠØªØ© ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
- âœ… Backpressure handling
- âœ… Ø­Ù…Ø§ÙŠØ© Ù…Ù† Ø±Ø³Ø§Ø¦Ù„ Ø¶Ø®Ù…Ø©
- âœ… Compression ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù„Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„ÙƒØ¨ÙŠØ±Ø©

---

##### **0.1 Heartbeat Ù‚ÙˆÙŠ ÙˆØ¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ø§ØªØµØ§Ù„Ø§Øª Ø§Ù„Ù…ÙŠØªØ©** ğŸ’“

**Implementation:**

```javascript
// /runtime/server/services/websocketBridge.js

class WebSocketBridge {
    constructor(server, sessionMonitor) {
        this.server = server;
        this.sessionMonitor = sessionMonitor;
        this.apiKey = process.env.API_KEY;
        this.clients = new Set();  // ØªØ¹Ù‚Ø¨ ÙŠØ¯ÙˆÙŠ Ù„Ù„Ø¹Ù…Ù„Ø§Ø¡
        this.healthInterval = null;
    }

    initialize() {
        try {
            this.wss = new WebSocket.Server({ 
                server: this.server,
                path: '/ws',
                clientTracking: false,           // âœ… Ù†Ù…Ø³Ùƒ Ø¥Ø­Ù†Ø§ Ø§Ù„Ù€ clients
                perMessageDeflate: {
                    threshold: 1024,              // âœ… Ø¶ØºØ· Ù„Ù„Ø±Ø³Ø§Ø¦Ù„ > 1KB ÙÙ‚Ø·
                    zlibDeflateOptions: {
                        level: 6,                 // ØªÙˆØ§Ø²Ù† Ø¨ÙŠÙ† Ø§Ù„Ø³Ø±Ø¹Ø© ÙˆØ§Ù„Ø¶ØºØ·
                    },
                    zlibInflateOptions: {
                        chunkSize: 10 * 1024
                    },
                    clientNoContextTakeover: true,
                    serverNoContextTakeover: true,
                    serverMaxWindowBits: 10,
                    concurrencyLimit: 10,
                },
                maxPayload: 1024 * 1024,         // âœ… 1MB Ø­Ù…Ø§ÙŠØ© Ù…Ù† Ø±Ø³Ø§Ø¦Ù„ Ø¶Ø®Ù…Ø©
            });

            this.setupEventHandlers();
            this.setupHealthCheck();
            
            // Connect to session monitor
            if (this.sessionMonitor) {
                this.sessionMonitor.setWebSocketBroadcast(
                    this.broadcast.bind(this)
                );
            }

            logger.info('WebSocket bridge initialized with heartbeat & compression');
        } catch (error) {
            logger.error('Failed to initialize WebSocket bridge:', error);
            throw error;
        }
    }

    setupEventHandlers() {
        this.wss.on('connection', (ws, req) => {
            // âœ… ØªØ¹Ù‚Ø¨ Ø­Ø§Ù„Ø© Ø§Ù„Ø§ØªØµØ§Ù„
            ws.isAlive = true;
            ws.ip = req.socket.remoteAddress;
            ws.connectedAt = Date.now();

            logger.info(`WebSocket client connected from ${ws.ip}`);

            // Authentication check
            const apiKey = this.extractApiKey(req);
            if (!this.validateApiKey(apiKey)) {
                logger.warn('WebSocket connection rejected: Invalid API key');
                ws.close(1008, 'Invalid API key');
                return;
            }

            // âœ… Add to clients set
            this.clients.add(ws);
            ws.isAuthenticated = true;

            // âœ… Pong handler - ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ø§ØªØµØ§Ù„
            ws.on('pong', () => { 
                ws.isAlive = true;
                logger.debug(`Pong received from ${ws.ip}`);
            });

            // Send initial session state
            this.sendSessionState(ws);
            this.sendQRCode(ws);

            // Handle messages from client
            ws.on('message', (message) => {
                this.handleClientMessage(ws, message);
            });

            // Handle client disconnect
            ws.on('close', (code, reason) => {
                this.clients.delete(ws);
                const duration = Date.now() - ws.connectedAt;
                logger.info(`WebSocket client disconnected: ${ws.ip} (code: ${code}, duration: ${Math.round(duration/1000)}s)`);
            });

            // Handle errors
            ws.on('error', (error) => {
                logger.error('WebSocket client error:', error);
                this.clients.delete(ws);
            });
        });

        this.wss.on('error', (error) => {
            logger.error('WebSocket server error:', error);
        });
    }

    /**
     * âœ… Setup health check - ÙØ­Øµ Ø§Ù„ØµØ­Ø© ÙƒÙ„ 30 Ø«Ø§Ù†ÙŠØ©
     */
    setupHealthCheck() {
        this.healthInterval = setInterval(() => {
            let alive = 0;
            let dead = 0;

            for (const ws of this.clients) {
                // âœ… Ø¥Ø°Ø§ Ù„Ù… ÙŠØ±Ø¯ Ø¹Ù„Ù‰ Ø¢Ø®Ø± pingØŒ Ø§Ù‚Ø·Ø¹ Ø§Ù„Ø§ØªØµØ§Ù„
                if (ws.isAlive === false) {
                    logger.warn(`Terminating dead connection from ${ws.ip}`);
                    try { 
                        ws.terminate(); 
                    } catch (err) {
                        logger.error('Error terminating connection:', err);
                    }
                    this.clients.delete(ws);
                    dead++;
                    continue;
                }

                // âœ… Ø§Ø±Ø³Ù„ ping Ø¬Ø¯ÙŠØ¯
                ws.isAlive = false;
                try { 
                    ws.ping();
                    alive++;
                } catch (err) {
                    logger.error('Error sending ping:', err);
                    this.clients.delete(ws);
                    dead++;
                }
            }

            if (alive > 0 || dead > 0) {
                logger.debug(`Health check: ${alive} alive, ${dead} dead connections cleaned`);
            }
        }, 30000); // ÙƒÙ„ 30 Ø«Ø§Ù†ÙŠØ©

        logger.info('WebSocket health check started (30s interval)');
    }

    // ... rest of the methods
}
```

---

##### **0.2 Backpressure ÙˆØ­Ù…Ø§ÙŠØ© Ø§Ù„Ø°Ø§ÙƒØ±Ø©** ğŸ›¡ï¸

**Implementation:**

```javascript
// /runtime/server/services/websocketBridge.js

class WebSocketBridge {
    /**
     * âœ… Safe send - Ù„Ø§ ØªØ¨Ø¹Ø« Ù„Ùˆ Ø§Ù„Ù€ buffer Ù…Ø²Ø¯Ø­Ù…
     */
    safeSend(ws, data) {
        // Check if connection is open
        if (ws.readyState !== WebSocket.OPEN) {
            logger.debug('Cannot send: WebSocket not open');
            return false;
        }

        // âœ… Check backpressure - Ù„Ùˆ Ø§Ù„Ù€ buffer > 512KBØŒ Ù„Ø§ ØªØ±Ø³Ù„
        if (ws.bufferedAmount > 512 * 1024) {
            logger.warn(`Backpressure detected: ${ws.bufferedAmount} bytes buffered for ${ws.ip}`);
            return false;
        }

        try {
            const message = typeof data === 'string' ? data : JSON.stringify(data);
            ws.send(message);
            return true;
        } catch (error) {
            logger.error('Error sending message:', error);
            return false;
        }
    }

    /**
     * âœ… Send message to a specific client (with backpressure)
     */
    send(ws, data) {
        const message = {
            type: data.type || 'message',
            data: data.data || data,
            timestamp: Date.now()
        };

        return this.safeSend(ws, message);
    }

    /**
     * âœ… Broadcast message to all connected clients (with backpressure)
     */
    broadcast(type, data) {
        const message = {
            type,
            data,
            timestamp: Date.now()
        };

        let sent = 0;
        let skipped = 0;

        for (const client of this.clients) {
            if (!client.isAuthenticated) {
                continue;
            }

            // Check subscriptions
            if (client.subscriptions && 
                !client.subscriptions.includes('all') && 
                !client.subscriptions.includes(type)) {
                continue;
            }

            // âœ… Use safeSend with backpressure check
            if (this.safeSend(client, message)) {
                sent++;
            } else {
                skipped++;
            }
        }

        if (sent > 0) {
            logger.debug(`Broadcast sent to ${sent} clients: ${type} (${skipped} skipped due to backpressure)`);
        }

        return { sent, skipped };
    }

    /**
     * âœ… Broadcast with priority (for critical messages)
     */
    broadcastPriority(type, data) {
        const message = {
            type,
            data,
            timestamp: Date.now(),
            priority: 'high'
        };

        let sent = 0;

        for (const client of this.clients) {
            if (!client.isAuthenticated) continue;

            // âœ… For priority messages, send even if buffer is slightly full
            if (client.readyState === WebSocket.OPEN) {
                // Allow up to 1MB for priority messages
                if (client.bufferedAmount < 1024 * 1024) {
                    try {
                        client.send(JSON.stringify(message));
                        sent++;
                    } catch (error) {
                        logger.error('Error sending priority message:', error);
                    }
                }
            }
        }

        logger.info(`Priority broadcast sent to ${sent} clients: ${type}`);
        return sent;
    }

    /**
     * âœ… Get buffer statistics
     */
    getBufferStats() {
        const stats = {
            clients: this.clients.size,
            totalBuffered: 0,
            maxBuffered: 0,
            avgBuffered: 0,
            overloaded: 0
        };

        for (const client of this.clients) {
            const buffered = client.bufferedAmount;
            stats.totalBuffered += buffered;
            stats.maxBuffered = Math.max(stats.maxBuffered, buffered);
            
            if (buffered > 512 * 1024) {
                stats.overloaded++;
            }
        }

        if (stats.clients > 0) {
            stats.avgBuffered = Math.round(stats.totalBuffered / stats.clients);
        }

        return stats;
    }

    /**
     * âœ… Cleanup on shutdown
     */
    shutdown() {
        // Clear health check interval
        if (this.healthInterval) {
            clearInterval(this.healthInterval);
            this.healthInterval = null;
        }

        // Close all connections gracefully
        for (const client of this.clients) {
            try {
                client.close(1000, 'Server shutting down');
            } catch (error) {
                logger.error('Error closing client connection:', error);
            }
        }

        this.clients.clear();

        // Close WebSocket server
        if (this.wss) {
            this.wss.close(() => {
                logger.info('WebSocket server closed');
            });
        }
    }
}

module.exports = WebSocketBridge;
```

---

##### **0.3 Monitoring & Statistics** ğŸ“Š

**Implementation:**

```javascript
// /runtime/server/services/websocketBridge.js

class WebSocketBridge {
    /**
     * âœ… Get detailed connection statistics
     */
    getDetailedStats() {
        const stats = {
            connections: {
                total: this.clients.size,
                authenticated: 0,
                alive: 0,
                dead: 0
            },
            buffer: this.getBufferStats(),
            uptime: process.uptime(),
            timestamp: new Date().toISOString()
        };

        for (const client of this.clients) {
            if (client.isAuthenticated) stats.connections.authenticated++;
            if (client.isAlive) stats.connections.alive++;
            else stats.connections.dead++;
        }

        return stats;
    }

    /**
     * âœ… Log statistics periodically
     */
    startStatsLogging(intervalMs = 60000) {
        setInterval(() => {
            const stats = this.getDetailedStats();
            logger.info('WebSocket Statistics:', {
                clients: stats.connections.total,
                authenticated: stats.connections.authenticated,
                alive: stats.connections.alive,
                avgBuffer: `${Math.round(stats.buffer.avgBuffered / 1024)}KB`,
                maxBuffer: `${Math.round(stats.buffer.maxBuffered / 1024)}KB`,
                overloaded: stats.buffer.overloaded
            });
        }, intervalMs);
    }
}
```

---

##### **0.4 Configuration** âš™ï¸

**Environment Variables:**

```bash
# .env

# WebSocket Settings
WEBSOCKET_MAX_PAYLOAD=1048576              # 1MB
WEBSOCKET_COMPRESSION_THRESHOLD=1024       # 1KB
WEBSOCKET_BACKPRESSURE_LIMIT=524288        # 512KB
WEBSOCKET_HEALTH_CHECK_INTERVAL=30000      # 30s
WEBSOCKET_STATS_LOG_INTERVAL=60000         # 60s

# Compression Settings
WEBSOCKET_COMPRESSION_LEVEL=6              # 1-9 (6 = balanced)
```

---

##### **0.5 Testing** ğŸ§ª

**Test Heartbeat:**

```javascript
// tests/websocket-heartbeat.test.js
const WebSocket = require('ws');

describe('WebSocket Heartbeat', () => {
    it('should terminate dead connections after 30s', (done) => {
        const ws = new WebSocket('ws://localhost:8080/ws?apiKey=test');
        
        ws.on('open', () => {
            // Don't respond to pings
            ws.on('ping', () => {
                // Ignore ping - simulate dead connection
            });
        });

        ws.on('close', (code) => {
            expect(code).toBe(1006); // Abnormal closure
            done();
        });

        // Should be terminated after 30s
    }, 35000);
});
```

**Test Backpressure:**

```javascript
// tests/websocket-backpressure.test.js
describe('WebSocket Backpressure', () => {
    it('should skip messages when buffer is full', (done) => {
        const ws = new WebSocket('ws://localhost:8080/ws?apiKey=test');
        
        ws.on('open', () => {
            // Pause reading to fill buffer
            ws.pause();
            
            // Try to send many messages
            for (let i = 0; i < 1000; i++) {
                // Some messages should be skipped
            }
            
            done();
        });
    });
});
```

---

##### **0.6 Benefits** âœ¨

**Ø§Ù„ÙÙˆØ§Ø¦Ø¯:**

1. **âœ… Stability (Ø§Ù„Ø§Ø³ØªÙ‚Ø±Ø§Ø±)**
   - Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ø§ØªØµØ§Ù„Ø§Øª Ø§Ù„Ù…ÙŠØªØ© ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
   - Ù„Ø§ ØªØ±Ø§ÙƒÙ… Ù„Ù„Ù€ zombie connections
   - Memory leak prevention

2. **âœ… Performance (Ø§Ù„Ø£Ø¯Ø§Ø¡)**
   - Compression ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù„Ù„Ø±Ø³Ø§Ø¦Ù„ > 1KB
   - Backpressure handling ÙŠÙ…Ù†Ø¹ ØªØ¬Ù…ÙŠØ¯ Ø§Ù„Ø³ÙŠØ±ÙØ±
   - Buffer overflow protection

3. **âœ… Reliability (Ø§Ù„Ù…ÙˆØ«ÙˆÙ‚ÙŠØ©)**
   - Heartbeat ÙƒÙ„ 30 Ø«Ø§Ù†ÙŠØ©
   - Dead connection detection
   - Graceful shutdown

4. **âœ… Monitoring (Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©)**
   - Buffer statistics
   - Connection health tracking
   - Detailed logging

---

##### **0.7 Topics/Rooms Ø®ÙÙŠÙØ© (Ø¨Ø¯Ù„ Namespaces)** ğŸ“¢

**Ø§Ù„Ù…Ø´ÙƒÙ„Ø©:**
- Ø­Ø§Ù„ÙŠØ§Ù‹ broadcast Ø¹Ø§Ù… Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡
- Ù„Ø§ ÙŠÙˆØ¬Ø¯ ØªØµÙ†ÙŠÙ Ù„Ù„Ø£Ø­Ø¯Ø§Ø«

**Ø§Ù„Ø­Ù„:**
- âœ… Topics Ø®ÙÙŠÙØ© Ø¨Ø¯ÙˆÙ† Socket.io
- âœ… Subscribe/Unsubscribe Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠ
- âœ… Publish Ù„Ù€ topic Ù…Ø­Ø¯Ø¯ ÙÙ‚Ø·

**Implementation:**

```javascript
// /runtime/server/services/websocketBridge.js

class WebSocketBridge {
    constructor(server, sessionMonitor) {
        // ... existing code
        this.topics = new Map(); // topic => Set<ws>
    }

    /**
     * âœ… Subscribe client to a topic
     */
    subscribe(ws, topic) {
        if (!this.topics.has(topic)) {
            this.topics.set(topic, new Set());
        }
        
        this.topics.get(topic).add(ws);
        logger.debug(`Client ${ws.ip} subscribed to topic: ${topic}`);

        // Auto-unsubscribe on close
        ws.on('close', () => {
            this.topics.get(topic)?.delete(ws);
            logger.debug(`Client ${ws.ip} unsubscribed from topic: ${topic}`);
        });
    }

    /**
     * âœ… Unsubscribe client from a topic
     */
    unsubscribe(ws, topic) {
        const subscribers = this.topics.get(topic);
        if (subscribers) {
            subscribers.delete(ws);
            logger.debug(`Client ${ws.ip} unsubscribed from topic: ${topic}`);
        }
    }

    /**
     * âœ… Publish message to a specific topic
     */
    publish(topic, payload) {
        const subscribers = this.topics.get(topic);
        if (!subscribers || subscribers.size === 0) {
            logger.debug(`No subscribers for topic: ${topic}`);
            return { sent: 0, skipped: 0 };
        }

        const message = {
            topic,
            data: payload,
            timestamp: Date.now()
        };

        let sent = 0;
        let skipped = 0;

        for (const ws of subscribers) {
            if (this.safeSend(ws, message)) {
                sent++;
            } else {
                skipped++;
            }
        }

        logger.debug(`Published to topic '${topic}': ${sent} sent, ${skipped} skipped`);
        return { sent, skipped };
    }

    /**
     * âœ… Get topic statistics
     */
    getTopicStats() {
        const stats = {};
        for (const [topic, subscribers] of this.topics.entries()) {
            stats[topic] = subscribers.size;
        }
        return stats;
    }

    /**
     * âœ… Handle subscribe message from client
     */
    handleClientMessage(ws, message) {
        try {
            const data = JSON.parse(message);

            switch (data.type) {
                case 'subscribe':
                    // Subscribe to topics
                    if (Array.isArray(data.topics)) {
                        data.topics.forEach(topic => this.subscribe(ws, topic));
                        this.send(ws, { 
                            type: 'subscribed', 
                            topics: data.topics 
                        });
                    }
                    break;

                case 'unsubscribe':
                    // Unsubscribe from topics
                    if (Array.isArray(data.topics)) {
                        data.topics.forEach(topic => this.unsubscribe(ws, topic));
                        this.send(ws, { 
                            type: 'unsubscribed', 
                            topics: data.topics 
                        });
                    }
                    break;

                // ... existing cases
            }
        } catch (error) {
            logger.error('Error handling WebSocket message:', error);
        }
    }
}
```

**Usage Examples:**

```javascript
// Publish QR code to 'session' topic
websocketBridge.publish('session', { 
    type: 'qr', 
    qr: qrCode 
});

// Publish notification to 'notifications' topic
websocketBridge.publish('notifications', { 
    type: 'new', 
    notification: notificationData 
});

// Publish campaign progress to 'campaigns' topic
websocketBridge.publish('campaigns', { 
    type: 'progress', 
    campaignId: id,
    progress: 50 
});
```

**Frontend Subscription:**

```javascript
// dashboard/src/hooks/useWebSocket.js

// Subscribe to topics on connect
ws.onopen = () => {
    ws.send(JSON.stringify({
        type: 'subscribe',
        topics: ['session', 'notifications', 'campaigns']
    }));
};

// Handle topic messages
ws.onmessage = (event) => {
    const data = JSON.parse(event.data);
    
    if (data.topic) {
        // Handle by topic
        switch (data.topic) {
            case 'session':
                handleSessionUpdate(data.data);
                break;
            case 'notifications':
                handleNotification(data.data);
                break;
            case 'campaigns':
                handleCampaignUpdate(data.data);
                break;
        }
    }
};
```

---

##### **0.8 Reconnect Ù…Ø­Ø³Ù‘Ù† Ù…Ø¹ Jitter** ğŸ”„

**Ø§Ù„ØªØ­Ø³ÙŠÙ†Ø§Øª:**
- âœ… Exponential backoff Ù…Ø¹ jitter
- âœ… Ø­Ø¯ Ø£Ù‚ØµÙ‰ 30 Ø«Ø§Ù†ÙŠØ©
- âœ… Reset Ø¹Ù„Ù‰ Ø§Ù„Ø§ØªØµØ§Ù„ Ø§Ù„Ù†Ø§Ø¬Ø­

**Implementation:**

```javascript
// /dashboard/src/hooks/useWebSocket.js

export function useWebSocket() {
    const [isConnected, setIsConnected] = useState(false);
    const [reconnectAttempts, setReconnectAttempts] = useState(0);
    const wsRef = useRef(null);
    const reconnectTimeoutRef = useRef(null);

    /**
     * âœ… Calculate next reconnect delay with jitter
     */
    const getReconnectDelay = useCallback((attempts) => {
        // Exponential backoff: 1s, 2s, 4s, 8s, 16s, 30s (max)
        const base = Math.min(1000 * Math.pow(2, attempts), 30000);
        
        // Add random jitter (0-1000ms) to avoid thundering herd
        const jitter = Math.floor(Math.random() * 1000);
        
        return base + jitter;
    }, []);

    /**
     * âœ… Schedule reconnection
     */
    const scheduleReconnect = useCallback(() => {
        if (reconnectTimeoutRef.current) {
            clearTimeout(reconnectTimeoutRef.current);
        }

        const delay = getReconnectDelay(reconnectAttempts);
        console.log(`ğŸ”„ Reconnecting in ${delay}ms (attempt ${reconnectAttempts + 1})`);

        reconnectTimeoutRef.current = setTimeout(() => {
            setReconnectAttempts(prev => prev + 1);
            connect();
        }, delay);
    }, [reconnectAttempts, getReconnectDelay]);

    const connect = useCallback(() => {
        try {
            const wsUrl = getWebSocketUrl();
            const apiKey = process.env.NEXT_PUBLIC_API_KEY || '';
            const fullUrl = apiKey ? `${wsUrl}?apiKey=${apiKey}` : wsUrl;

            const ws = new WebSocket(fullUrl);
            wsRef.current = ws;

            ws.onopen = () => {
                console.log('âœ… WebSocket connected');
                setIsConnected(true);
                setReconnectAttempts(0); // âœ… Reset attempts on successful connection

                // Subscribe to topics
                ws.send(JSON.stringify({
                    type: 'subscribe',
                    topics: ['session', 'notifications', 'campaigns']
                }));
            };

            ws.onmessage = (event) => {
                // ... existing message handling
            };

            ws.onerror = (error) => {
                console.error('âŒ WebSocket error:', error);
                setIsConnected(false);
            };

            ws.onclose = (event) => {
                console.warn('âš ï¸ WebSocket disconnected:', event.code, event.reason);
                setIsConnected(false);
                
                // âœ… Schedule reconnect with backoff
                scheduleReconnect();
            };
        } catch (err) {
            console.error('âŒ Failed to create WebSocket:', err);
            scheduleReconnect();
        }
    }, [scheduleReconnect]);

    useEffect(() => {
        connect();

        return () => {
            if (reconnectTimeoutRef.current) {
                clearTimeout(reconnectTimeoutRef.current);
            }
            if (wsRef.current) {
                wsRef.current.close();
            }
        };
    }, [connect]);

    return {
        isConnected,
        reconnectAttempts,
        // ... other returns
    };
}
```

---

##### **0.9 Message Validation Ù…Ø¹ Zod** âœ…

**Ø§Ù„Ù…Ø´ÙƒÙ„Ø©:**
- Ù„Ø§ ÙŠÙˆØ¬Ø¯ validation Ù„Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„ÙˆØ§Ø±Ø¯Ø©
- Ø®Ø·Ø± Ù…Ù† Ø±Ø³Ø§Ø¦Ù„ malformed

**Ø§Ù„Ø­Ù„:**
- âœ… Zod schema validation
- âœ… Type-safe message handling
- âœ… Reject invalid messages

**Implementation:**

```javascript
// /runtime/server/services/websocketBridge.js
const { z } = require('zod');

// âœ… Define message schemas
const SubscribeSchema = z.object({
    type: z.literal('subscribe'),
    topics: z.array(z.string()).min(1)
});

const UnsubscribeSchema = z.object({
    type: z.literal('unsubscribe'),
    topics: z.array(z.string()).min(1)
});

const PingSchema = z.object({
    type: z.literal('ping')
});

const GetStateSchema = z.object({
    type: z.literal('get_state')
});

// âœ… Union of all valid message types
const IncomingMessageSchema = z.discriminatedUnion('type', [
    SubscribeSchema,
    UnsubscribeSchema,
    PingSchema,
    GetStateSchema
]);

class WebSocketBridge {
    /**
     * âœ… Handle incoming message with validation
     */
    handleClientMessage(ws, rawMessage) {
        // Parse JSON
        let message;
        try {
            message = JSON.parse(rawMessage);
        } catch (error) {
            logger.warn(`Invalid JSON from ${ws.ip}`);
            this.send(ws, { 
                type: 'error', 
                message: 'Invalid JSON format' 
            });
            return;
        }

        // âœ… Validate with Zod
        const result = IncomingMessageSchema.safeParse(message);
        
        if (!result.success) {
            logger.warn(`Invalid message schema from ${ws.ip}:`, result.error.errors);
            this.send(ws, { 
                type: 'error', 
                message: 'Invalid message format',
                errors: result.error.errors 
            });
            return;
        }

        // âœ… Handle validated message
        const validatedMessage = result.data;

        switch (validatedMessage.type) {
            case 'subscribe':
                validatedMessage.topics.forEach(topic => this.subscribe(ws, topic));
                this.send(ws, { 
                    type: 'subscribed', 
                    topics: validatedMessage.topics 
                });
                break;

            case 'unsubscribe':
                validatedMessage.topics.forEach(topic => this.unsubscribe(ws, topic));
                this.send(ws, { 
                    type: 'unsubscribed', 
                    topics: validatedMessage.topics 
                });
                break;

            case 'ping':
                this.send(ws, { type: 'pong', timestamp: Date.now() });
                break;

            case 'get_state':
                this.sendSessionState(ws);
                break;

            default:
                // TypeScript will ensure this is never reached
                break;
        }
    }
}
```

**Dependencies:**

```json
// package.json
{
  "dependencies": {
    "zod": "^3.22.4"
  }
}
```

---

##### **0.10 Metrics Endpoint** ğŸ“Š

**Implementation:**

```javascript
// /runtime/server/index.js

// âœ… Metrics object
const metrics = {
    connections: 0,
    disconnections: 0,
    messages: 0,
    errors: 0,
    broadcasts: 0,
    lastQR: null,
    startTime: Date.now()
};

// âœ… Track events
websocketBridge.on('connection', () => {
    metrics.connections++;
});

websocketBridge.on('disconnect', () => {
    metrics.disconnections++;
});

websocketBridge.on('message', () => {
    metrics.messages++;
});

websocketBridge.on('error', () => {
    metrics.errors++;
});

websocketBridge.on('broadcast', (topic) => {
    metrics.broadcasts++;
    if (topic === 'session' || topic === 'qr') {
        metrics.lastQR = new Date().toISOString();
    }
});

// âœ… Metrics endpoint
app.get('/api/metrics', authenticateApiKey, (req, res) => {
    const stats = websocketBridge.getDetailedStats();
    const topicStats = websocketBridge.getTopicStats();
    
    res.json({
        metrics: {
            ...metrics,
            uptime: Math.floor((Date.now() - metrics.startTime) / 1000),
            uptimeFormatted: formatUptime(Date.now() - metrics.startTime)
        },
        websocket: {
            clients: stats.connections.total,
            authenticated: stats.connections.authenticated,
            alive: stats.connections.alive,
            dead: stats.connections.dead
        },
        topics: topicStats,
        buffer: stats.buffer,
        timestamp: new Date().toISOString()
    });
});

function formatUptime(ms) {
    const seconds = Math.floor(ms / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);
    
    if (days > 0) return `${days}d ${hours % 24}h`;
    if (hours > 0) return `${hours}h ${minutes % 60}m`;
    if (minutes > 0) return `${minutes}m ${seconds % 60}s`;
    return `${seconds}s`;
}
```

**Update WebSocketBridge to emit events:**

```javascript
// /runtime/server/services/websocketBridge.js
const EventEmitter = require('events');

class WebSocketBridge extends EventEmitter {
    setupEventHandlers() {
        this.wss.on('connection', (ws, req) => {
            // ... existing code
            this.emit('connection'); // âœ… Emit event
        });

        ws.on('close', () => {
            // ... existing code
            this.emit('disconnect'); // âœ… Emit event
        });

        ws.on('message', (message) => {
            this.emit('message'); // âœ… Emit event
            this.handleClientMessage(ws, message);
        });

        ws.on('error', (error) => {
            this.emit('error', error); // âœ… Emit event
        });
    }

    publish(topic, payload) {
        // ... existing code
        this.emit('broadcast', topic); // âœ… Emit event
        return { sent, skipped };
    }
}
```

**Access Metrics:**

```bash
# Get metrics
curl -H "X-API-Key: your-key" http://localhost:8080/api/metrics

# Response:
{
  "metrics": {
    "connections": 150,
    "disconnections": 145,
    "messages": 5234,
    "errors": 2,
    "broadcasts": 1523,
    "lastQR": "2025-10-31T08:15:30.123Z",
    "uptime": 86400,
    "uptimeFormatted": "1d 0h"
  },
  "websocket": {
    "clients": 5,
    "authenticated": 5,
    "alive": 5,
    "dead": 0
  },
  "topics": {
    "session": 5,
    "notifications": 3,
    "campaigns": 2
  },
  "buffer": {
    "clients": 5,
    "totalBuffered": 2048,
    "maxBuffered": 512,
    "avgBuffered": 410,
    "overloaded": 0
  },
  "timestamp": "2025-10-31T08:19:00.000Z"
}
```

---

##### **0.11 Summary** ğŸ“

**Ø§Ù„ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„Ù…ÙØ¶Ø§ÙØ©:**

1. **âœ… Topics/Rooms** - Subscribe/Publish Ø®ÙÙŠÙ
2. **âœ… Reconnect Ù…Ø­Ø³Ù‘Ù†** - Exponential backoff + jitter
3. **âœ… Message Validation** - Zod schema validation
4. **âœ… Metrics Endpoint** - HTTP endpoint Ù„Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©

**Ø§Ù„ÙÙˆØ§Ø¦Ø¯:**

- ğŸ¯ **Targeted Broadcasting** - Ø¥Ø±Ø³Ø§Ù„ Ù„Ù„Ù…Ø´ØªØ±ÙƒÙŠÙ† ÙÙ‚Ø·
- ğŸ”„ **Smart Reconnection** - ØªØ¬Ù†Ø¨ thundering herd
- âœ… **Type Safety** - Zod validation
- ğŸ“Š **Observability** - Metrics endpoint

---

##### **0.12 Ø§Ù„Ø¬Ø§Ù†Ø¨ Ø§Ù„Ø£Ù…Ù†ÙŠ - Native WebSocket Security** ğŸ”’

**Ø§Ù„Ù…Ø´ÙƒÙ„Ø©:**
- WebSocket Ù„Ø§ ÙŠØ·Ø¨Ù‚ CORS ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
- Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø­Ù…Ø§ÙŠØ© Ù…Ù† replay attacks
- Ù„Ø§ ÙŠÙˆØ¬Ø¯ IP whitelisting
- Rate limiting Ø¨Ø³ÙŠØ· Ø¬Ø¯Ø§Ù‹

**Ø§Ù„Ø­Ù„:**
- âœ… HMAC Authentication Ù…Ø¹ timestamp
- âœ… Origin validation
- âœ… IP whitelisting
- âœ… Token bucket rate limiting
- âœ… Message size limits

---

###### **0.12.1 HMAC Authentication + Timestamp + IP** ğŸ”

**Implementation:**

```javascript
// /runtime/server/services/websocketBridge.js
const crypto = require('crypto');

class WebSocketBridge {
    constructor(server, sessionMonitor) {
        // ... existing code
        this.serverSecret = process.env.SERVER_SECRET || 'change-me-in-production';
        this.allowedIPs = process.env.ALLOWED_IPS ? 
            process.env.ALLOWED_IPS.split(',') : [];
    }

    /**
     * âœ… Generate HMAC signature
     */
    generateHMAC(data, secret) {
        return crypto.createHmac('sha256', secret)
            .update(data)
            .digest('hex');
    }

    /**
     * âœ… Validate handshake with HMAC + timestamp + IP
     */
    validateHandshake(reqUrl, ip) {
        try {
            const url = new URL(reqUrl, 'http://placeholder');
            const apiKey = url.searchParams.get('apiKey');
            const ts = url.searchParams.get('ts');
            const sig = url.searchParams.get('sig');

            // âœ… Check required parameters
            if (!apiKey || !ts || !sig) {
                logger.warn(`Missing auth parameters from ${ip}`);
                return false;
            }

            // âœ… Check timestamp (reject if older than 60 seconds)
            const timestamp = Number(ts);
            const now = Date.now();
            const age = Math.abs(now - timestamp);
            
            if (age > 60_000) {
                logger.warn(`Expired timestamp from ${ip}: ${age}ms old`);
                return false;
            }

            // âœ… Check IP whitelist (if configured)
            if (this.allowedIPs.length > 0 && !this.allowedIPs.includes(ip)) {
                logger.warn(`IP not whitelisted: ${ip}`);
                return false;
            }

            // âœ… Verify HMAC signature
            const data = apiKey + ts + ip;
            const expectedSig = this.generateHMAC(data, this.serverSecret);
            
            // Use timing-safe comparison
            const sigBuffer = Buffer.from(sig, 'hex');
            const expectedBuffer = Buffer.from(expectedSig, 'hex');
            
            if (sigBuffer.length !== expectedBuffer.length) {
                logger.warn(`Invalid signature length from ${ip}`);
                return false;
            }

            const isValid = crypto.timingSafeEqual(sigBuffer, expectedBuffer);
            
            if (!isValid) {
                logger.warn(`Invalid signature from ${ip}`);
                return false;
            }

            // âœ… Verify API key
            if (apiKey !== process.env.API_KEY) {
                logger.warn(`Invalid API key from ${ip}`);
                return false;
            }

            logger.info(`âœ… Valid handshake from ${ip}`);
            return { apiKey, ip, timestamp };
        } catch (error) {
            logger.error('Error validating handshake:', error);
            return false;
        }
    }

    setupEventHandlers() {
        this.wss.on('connection', (ws, req) => {
            const ip = req.socket.remoteAddress;
            
            // âœ… Validate handshake
            const auth = this.validateHandshake(req.url, ip);
            if (!auth) {
                logger.warn(`Unauthorized connection attempt from ${ip}`);
                try {
                    ws.close(1008, 'Unauthorized');
                } catch (error) {
                    logger.error('Error closing unauthorized connection:', error);
                }
                return;
            }

            // âœ… Store authenticated user info
            ws.user = {
                apiKey: auth.apiKey,
                ip: auth.ip,
                authenticatedAt: auth.timestamp
            };
            ws.isAuthenticated = true;
            ws.isAlive = true;
            ws.ip = ip;
            ws.connectedAt = Date.now();

            logger.info(`âœ… Authenticated connection from ${ip}`);

            // ... rest of connection handling
        });
    }
}
```

**Frontend - Generate Signature:**

```javascript
// /dashboard/src/hooks/useWebSocket.js
import CryptoJS from 'crypto-js';

function generateSignature(apiKey, timestamp, serverSecret) {
    const data = apiKey + timestamp;
    return CryptoJS.HmacSHA256(data, serverSecret).toString();
}

function getWebSocketUrl() {
    const baseUrl = process.env.NEXT_PUBLIC_WS_URL || 'ws://localhost:8080';
    const apiKey = process.env.NEXT_PUBLIC_API_KEY;
    const serverSecret = process.env.NEXT_PUBLIC_SERVER_SECRET;
    
    // âœ… Generate timestamp
    const timestamp = Date.now();
    
    // âœ… Generate signature (client IP will be added by server)
    // Note: In production, get IP from server first or use server-side auth
    const signature = generateSignature(apiKey, timestamp, serverSecret);
    
    return `${baseUrl}/ws?apiKey=${apiKey}&ts=${timestamp}&sig=${signature}`;
}
```

**Dependencies:**

```json
// Frontend package.json
{
  "dependencies": {
    "crypto-js": "^4.2.0"
  }
}
```

---

###### **0.12.2 Origin Validation (CORS Ù„Ù„Ù€ WebSocket)** ğŸŒ

**Implementation:**

```javascript
// /runtime/server/services/websocketBridge.js

class WebSocketBridge {
    constructor(server, sessionMonitor) {
        // ... existing code
        this.allowedOrigins = process.env.ALLOWED_ORIGINS ? 
            process.env.ALLOWED_ORIGINS.split(',') : [
                'http://localhost:3000',
                'http://localhost:3001',
                'https://dashboard.yourdomain.com'
            ];
    }

    /**
     * âœ… Check if origin is allowed
     */
    isAllowedOrigin(origin) {
        if (!origin) {
            logger.warn('No origin header provided');
            return false;
        }

        // Allow all origins in development
        if (process.env.NODE_ENV === 'development') {
            return true;
        }

        return this.allowedOrigins.includes(origin);
    }

    initialize() {
        try {
            this.wss = new WebSocket.Server({ 
                server: this.server,
                path: '/ws',
                clientTracking: false,
                perMessageDeflate: {
                    threshold: 1024,
                    zlibDeflateOptions: { level: 6 },
                    zlibInflateOptions: { chunkSize: 10 * 1024 },
                    clientNoContextTakeover: true,
                    serverNoContextTakeover: true,
                    serverMaxWindowBits: 10,
                    concurrencyLimit: 10,
                },
                maxPayload: 1024 * 1024,
                
                // âœ… Verify client before upgrade
                verifyClient: (info, callback) => {
                    const origin = info.req.headers.origin;
                    const ip = info.req.socket.remoteAddress;

                    // âœ… Check origin
                    if (!this.isAllowedOrigin(origin)) {
                        logger.warn(`Origin not allowed: ${origin} from ${ip}`);
                        callback(false, 403, 'Origin not allowed');
                        return;
                    }

                    // âœ… Pre-validate handshake (optional early check)
                    const auth = this.validateHandshake(info.req.url, ip);
                    if (!auth) {
                        logger.warn(`Invalid handshake from ${ip}`);
                        callback(false, 401, 'Unauthorized');
                        return;
                    }

                    callback(true);
                }
            });

            this.setupEventHandlers();
            this.setupHealthCheck();
            
            logger.info('WebSocket bridge initialized with security features');
        } catch (error) {
            logger.error('Failed to initialize WebSocket bridge:', error);
            throw error;
        }
    }
}
```

---

###### **0.12.3 Token Bucket Rate Limiting** ğŸª£

**Implementation:**

```javascript
// /runtime/server/services/websocketBridge.js

class WebSocketBridge {
    constructor(server, sessionMonitor) {
        // ... existing code
        this.rateLimitBuckets = new Map(); // ip => { tokens, lastRefill }
        this.rateLimitConfig = {
            capacity: 60,        // 60 tokens
            refillRate: 1,       // 1 token per interval
            refillInterval: 1000 // 1 second
        };
    }

    /**
     * âœ… Token bucket rate limiting
     */
    isRateLimitAllowed(ip, cost = 1) {
        const now = Date.now();
        const config = this.rateLimitConfig;
        
        // Get or create bucket
        let bucket = this.rateLimitBuckets.get(ip);
        if (!bucket) {
            bucket = {
                tokens: config.capacity,
                lastRefill: now
            };
            this.rateLimitBuckets.set(ip, bucket);
        }

        // âœ… Refill tokens based on elapsed time
        const elapsed = now - bucket.lastRefill;
        const refillCount = Math.floor(elapsed / config.refillInterval) * config.refillRate;
        
        if (refillCount > 0) {
            bucket.tokens = Math.min(config.capacity, bucket.tokens + refillCount);
            bucket.lastRefill = now;
        }

        // âœ… Check if enough tokens
        if (bucket.tokens < cost) {
            logger.warn(`Rate limit exceeded for ${ip}: ${bucket.tokens} tokens remaining`);
            return false;
        }

        // âœ… Consume tokens
        bucket.tokens -= cost;
        this.rateLimitBuckets.set(ip, bucket);
        
        return true;
    }

    /**
     * âœ… Clean up old buckets (call periodically)
     */
    cleanupRateLimitBuckets() {
        const now = Date.now();
        const maxAge = 5 * 60 * 1000; // 5 minutes

        for (const [ip, bucket] of this.rateLimitBuckets.entries()) {
            if (now - bucket.lastRefill > maxAge) {
                this.rateLimitBuckets.delete(ip);
            }
        }

        logger.debug(`Rate limit buckets cleaned: ${this.rateLimitBuckets.size} active`);
    }

    setupEventHandlers() {
        this.wss.on('connection', (ws, req) => {
            // ... existing auth code

            // Handle messages with rate limiting
            ws.on('message', (rawMessage) => {
                // âœ… Check rate limit
                if (!this.isRateLimitAllowed(ws.ip)) {
                    logger.warn(`Rate limit exceeded for ${ws.ip}, ignoring message`);
                    
                    // Send warning to client
                    this.send(ws, {
                        type: 'rate_limit_warning',
                        message: 'Too many messages, please slow down'
                    });
                    
                    // Optional: close connection after repeated violations
                    ws.rateLimitViolations = (ws.rateLimitViolations || 0) + 1;
                    if (ws.rateLimitViolations >= 5) {
                        logger.error(`Closing connection from ${ws.ip} due to repeated rate limit violations`);
                        try {
                            ws.close(1008, 'Rate limit exceeded');
                        } catch (error) {
                            logger.error('Error closing connection:', error);
                        }
                    }
                    
                    return;
                }

                // âœ… Reset violation counter on successful message
                ws.rateLimitViolations = 0;

                // Handle message
                this.handleClientMessage(ws, rawMessage);
            });

            // ... rest of connection handling
        });
    }

    setupHealthCheck() {
        this.healthInterval = setInterval(() => {
            // ... existing health check code

            // âœ… Cleanup rate limit buckets
            this.cleanupRateLimitBuckets();
        }, 30000);
    }
}
```

---

###### **0.12.4 Message Size & Type Limits** ğŸ“

**Implementation:**

```javascript
// /runtime/server/services/websocketBridge.js

class WebSocketBridge {
    constructor(server, sessionMonitor) {
        // ... existing code
        this.messageLimits = {
            maxSize: 10 * 1024,      // 10KB per message
            maxLength: 1000,          // 1000 characters for string fields
            allowedTypes: ['subscribe', 'unsubscribe', 'ping', 'get_state']
        };
    }

    /**
     * âœ… Validate message size and content
     */
    validateMessageSecurity(rawMessage, ws) {
        // âœ… Check message size
        const size = Buffer.byteLength(rawMessage);
        if (size > this.messageLimits.maxSize) {
            logger.warn(`Message too large from ${ws.ip}: ${size} bytes`);
            this.send(ws, {
                type: 'error',
                message: `Message too large: ${size} bytes (max: ${this.messageLimits.maxSize})`
            });
            return false;
        }

        // âœ… Parse JSON
        let message;
        try {
            message = JSON.parse(rawMessage);
        } catch (error) {
            logger.warn(`Invalid JSON from ${ws.ip}`);
            this.send(ws, {
                type: 'error',
                message: 'Invalid JSON format'
            });
            return false;
        }

        // âœ… Check message type
        if (!message.type || !this.messageLimits.allowedTypes.includes(message.type)) {
            logger.warn(`Invalid message type from ${ws.ip}: ${message.type}`);
            this.send(ws, {
                type: 'error',
                message: `Invalid message type: ${message.type}`
            });
            return false;
        }

        // âœ… Check string field lengths
        for (const [key, value] of Object.entries(message)) {
            if (typeof value === 'string' && value.length > this.messageLimits.maxLength) {
                logger.warn(`Field too long from ${ws.ip}: ${key} = ${value.length} chars`);
                this.send(ws, {
                    type: 'error',
                    message: `Field '${key}' too long: ${value.length} chars (max: ${this.messageLimits.maxLength})`
                });
                return false;
            }
        }

        return message;
    }

    handleClientMessage(ws, rawMessage) {
        // âœ… Validate security first
        const message = this.validateMessageSecurity(rawMessage, ws);
        if (!message) return;

        // âœ… Then validate with Zod
        const result = IncomingMessageSchema.safeParse(message);
        if (!result.success) {
            logger.warn(`Invalid message schema from ${ws.ip}:`, result.error.errors);
            this.send(ws, {
                type: 'error',
                message: 'Invalid message format',
                errors: result.error.errors
            });
            return;
        }

        // âœ… Handle validated message
        const validatedMessage = result.data;
        // ... existing message handling
    }
}
```

---

###### **0.12.5 Security Configuration** âš™ï¸

**Environment Variables:**

```bash
# .env

# Security Settings
SERVER_SECRET=your-secret-key-change-in-production
ALLOWED_ORIGINS=http://localhost:3000,https://dashboard.yourdomain.com
ALLOWED_IPS=                                    # Empty = allow all, or comma-separated IPs

# Rate Limiting
RATE_LIMIT_CAPACITY=60                          # 60 tokens
RATE_LIMIT_REFILL_RATE=1                        # 1 token per interval
RATE_LIMIT_REFILL_INTERVAL=1000                 # 1 second
RATE_LIMIT_MAX_VIOLATIONS=5                     # Close after 5 violations

# Message Limits
MESSAGE_MAX_SIZE=10240                          # 10KB
MESSAGE_MAX_STRING_LENGTH=1000                  # 1000 chars
MESSAGE_ALLOWED_TYPES=subscribe,unsubscribe,ping,get_state

# Handshake
HANDSHAKE_MAX_AGE=60000                         # 60 seconds
```

---

###### **0.12.6 Security Monitoring** ğŸ“Š

**Add to Metrics:**

```javascript
// /runtime/server/index.js

const securityMetrics = {
    unauthorizedAttempts: 0,
    rateLimitViolations: 0,
    invalidOrigins: 0,
    expiredHandshakes: 0,
    invalidSignatures: 0,
    oversizedMessages: 0
};

// Track security events
websocketBridge.on('unauthorized', () => {
    securityMetrics.unauthorizedAttempts++;
});

websocketBridge.on('rate_limit_violation', () => {
    securityMetrics.rateLimitViolations++;
});

websocketBridge.on('invalid_origin', () => {
    securityMetrics.invalidOrigins++;
});

// Add to metrics endpoint
app.get('/api/metrics', authenticateApiKey, (req, res) => {
    res.json({
        // ... existing metrics
        security: securityMetrics,
        // ...
    });
});
```

**Emit Security Events:**

```javascript
// /runtime/server/services/websocketBridge.js

class WebSocketBridge extends EventEmitter {
    validateHandshake(reqUrl, ip) {
        // ... validation code
        
        if (!apiKey || !ts || !sig) {
            this.emit('unauthorized', { reason: 'missing_params', ip });
            return false;
        }

        if (age > 60_000) {
            this.emit('unauthorized', { reason: 'expired_timestamp', ip, age });
            return false;
        }

        if (!isValid) {
            this.emit('unauthorized', { reason: 'invalid_signature', ip });
            return false;
        }

        return { apiKey, ip, timestamp };
    }

    isRateLimitAllowed(ip, cost = 1) {
        // ... rate limit code
        
        if (bucket.tokens < cost) {
            this.emit('rate_limit_violation', { ip, tokens: bucket.tokens });
            return false;
        }

        return true;
    }
}
```

---

###### **0.12.7 Security Summary** ğŸ“

**Ø§Ù„Ø­Ù…Ø§ÙŠØ© Ø§Ù„Ù…ÙØ·Ø¨Ù‘Ù‚Ø©:**

1. **âœ… HMAC Authentication**
   - Signature verification
   - Timestamp validation (60s window)
   - IP binding
   - Timing-safe comparison

2. **âœ… Origin Validation**
   - Whitelist-based
   - Pre-upgrade verification
   - Development mode bypass

3. **âœ… IP Whitelisting**
   - Optional configuration
   - Logged violations

4. **âœ… Token Bucket Rate Limiting**
   - 60 messages per minute per IP
   - Auto-refill
   - Violation tracking
   - Auto-disconnect after 5 violations

5. **âœ… Message Validation**
   - Size limits (10KB)
   - Type whitelist
   - String length limits
   - Zod schema validation

6. **âœ… Security Monitoring**
   - Event tracking
   - Metrics endpoint
   - Detailed logging

**Ø§Ù„ÙÙˆØ§Ø¦Ø¯:**

- ğŸ”’ **Strong Authentication** - HMAC + timestamp + IP
- ğŸŒ **Origin Protection** - CORS-like for WebSocket
- ğŸ›¡ï¸ **DDoS Protection** - Rate limiting per IP
- âœ… **Input Validation** - Multiple layers
- ğŸ“Š **Security Observability** - Metrics & logs

---

##### **0.13 Auto-Reconnect Ø§Ù„Ø±Ø³Ù…ÙŠ (RFC 6455 Compliant)** ğŸ”„

**ğŸ¯ Ø§Ù„Ù‡Ø¯Ù:**
- ØªØ·Ø¨ÙŠÙ‚ Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„ Ø§Ù„Ø±Ø³Ù…ÙŠ RFC 6455 ØªÙ…Ø§Ù…Ø§Ù‹
- Auto-reconnect Ø°ÙƒÙŠ (backoff + jitter)
- Heartbeat ØµØ§Ø±Ù… ÙŠÙƒØªØ´Ù Ø§Ù„Ø§ØªØµØ§Ù„Ø§Øª Ø§Ù„Ù…ÙŠØªØ©
- ÙˆØ§Ø¬Ù‡Ø© Ø¨Ø±Ù…Ø¬ÙŠØ© Ù†Ø¸ÙŠÙØ© ÙˆØ³Ù‡Ù„Ø© Ø§Ù„ØµÙŠØ§Ù†Ø©

---

###### **0.13.1 Server-Side Implementation (RFC 6455)** ğŸ–¥ï¸

**Ø§Ù„ØªÙ‡ÙŠØ¦Ø© Ø§Ù„ØµØ­ÙŠØ­Ø© ÙˆÙÙ‚ Ø¯Ù„ÙŠÙ„ `ws` Ø§Ù„Ø±Ø³Ù…ÙŠ:**

```javascript
// /runtime/server/services/websocketBridge.js
import { WebSocketServer } from 'ws';
import { EventEmitter } from 'events';

export class WebSocketBridge extends EventEmitter {
    constructor(server, sessionMonitor) {
        super();
        this.server = server;
        this.sessionMonitor = sessionMonitor;
        this.clients = new Set();
        this.heartbeatInterval = null;
    }

    /**
     * âœ… Initialize WebSocket Server (RFC 6455 Compliant)
     */
    initialize() {
        this.wss = new WebSocketServer({
            server: this.server,
            path: '/ws',
            
            // âœ… Compression (RFC 7692)
            perMessageDeflate: {
                threshold: 1024,              // Compress messages > 1KB
                zlibDeflateOptions: {
                    level: 6,                 // Balanced compression
                },
                zlibInflateOptions: {
                    chunkSize: 10 * 1024
                },
                clientNoContextTakeover: true,
                serverNoContextTakeover: true,
                serverMaxWindowBits: 10,
                concurrencyLimit: 10,
            },
            
            // âœ… Security limits
            maxPayload: 1024 * 1024,          // 1 MB max message size
            clientTracking: true,             // Track clients automatically
            
            // âœ… Verify client before upgrade
            verifyClient: (info, callback) => {
                const origin = info.req.headers.origin;
                const ip = info.req.socket.remoteAddress;

                // Check origin
                if (!this.isAllowedOrigin(origin)) {
                    logger.warn(`Origin not allowed: ${origin} from ${ip}`);
                    callback(false, 403, 'Origin not allowed');
                    return;
                }

                // Validate handshake
                const auth = this.validateHandshake(info.req.url, ip);
                if (!auth) {
                    logger.warn(`Invalid handshake from ${ip}`);
                    callback(false, 401, 'Unauthorized');
                    return;
                }

                callback(true);
            }
        });

        this.setupEvents();
        this.startHeartbeat();
        
        logger.info('âœ… WebSocket Server initialized (RFC 6455 compliant)');
    }

    /**
     * âœ… Setup connection events
     */
    setupEvents() {
        this.wss.on('connection', (ws, req) => {
            // âœ… Initialize connection state
            ws.isAlive = true;
            ws.ip = req.socket.remoteAddress;
            ws.connectedAt = Date.now();
            ws.subscriptions = [];

            logger.info(`âœ… Client connected: ${ws.ip}`);

            // âœ… Pong handler - mark as alive
            ws.on('pong', () => {
                ws.isAlive = true;
                logger.debug(`ğŸ’“ Pong received from ${ws.ip}`);
            });

            // âœ… Add to clients set
            this.clients.add(ws);
            this.emit('connection');

            // âœ… Send welcome message
            this.safeSend(ws, {
                type: 'welcome',
                message: 'Connected successfully',
                timestamp: Date.now(),
                server: 'WaQtor WebSocket Server v1.0'
            });

            // âœ… Handle incoming messages
            ws.on('message', (data) => {
                this.handleMessage(ws, data);
            });

            // âœ… Handle close
            ws.on('close', (code, reason) => {
                this.clients.delete(ws);
                const duration = Date.now() - ws.connectedAt;
                logger.info(`âŒ Client disconnected: ${ws.ip} (code: ${code}, duration: ${Math.round(duration/1000)}s)`);
                this.emit('disconnect');
            });

            // âœ… Handle errors
            ws.on('error', (error) => {
                logger.error(`âš ï¸ WebSocket error from ${ws.ip}:`, error);
                this.emit('error', error);
            });
        });

        this.wss.on('error', (error) => {
            logger.error('âŒ WebSocket Server error:', error);
        });
    }

    /**
     * âœ… Handle incoming messages
     */
    handleMessage(ws, raw) {
        try {
            const msg = JSON.parse(raw);
            this.emit('message');

            switch (msg.type) {
                case 'ping':
                    // Client-initiated ping
                    this.safeSend(ws, {
                        type: 'pong',
                        timestamp: Date.now()
                    });
                    break;

                case 'subscribe':
                    // Subscribe to events
                    ws.subscriptions = msg.events || ['all'];
                    this.safeSend(ws, {
                        type: 'subscribed',
                        events: ws.subscriptions
                    });
                    logger.info(`ğŸ“¡ Client ${ws.ip} subscribed to: ${ws.subscriptions.join(', ')}`);
                    break;

                case 'unsubscribe':
                    // Unsubscribe from events
                    ws.subscriptions = [];
                    this.safeSend(ws, {
                        type: 'unsubscribed'
                    });
                    logger.info(`ğŸ“¡ Client ${ws.ip} unsubscribed from all events`);
                    break;

                case 'get_state':
                    // Send current session state
                    this.sendSessionState(ws);
                    break;

                default:
                    logger.warn(`âš ï¸ Unknown message type from ${ws.ip}: ${msg.type}`);
                    this.safeSend(ws, {
                        type: 'error',
                        message: `Unknown message type: ${msg.type}`
                    });
                    break;
            }
        } catch (error) {
            logger.error(`âŒ Error handling message from ${ws.ip}:`, error);
            this.safeSend(ws, {
                type: 'error',
                message: 'Invalid message format'
            });
        }
    }

    /**
     * âœ… Safe send with backpressure check
     */
    safeSend(ws, data) {
        if (ws.readyState !== ws.OPEN) {
            return false;
        }

        // âœ… Check backpressure (512KB limit)
        if (ws.bufferedAmount > 512 * 1024) {
            logger.warn(`âš ï¸ Backpressure detected for ${ws.ip}: ${ws.bufferedAmount} bytes buffered`);
            return false;
        }

        try {
            ws.send(JSON.stringify(data));
            return true;
        } catch (error) {
            logger.error(`âŒ Error sending to ${ws.ip}:`, error);
            return false;
        }
    }

    /**
     * âœ… Start heartbeat (ping/pong every 30s)
     */
    startHeartbeat() {
        this.heartbeatInterval = setInterval(() => {
            let alive = 0;
            let dead = 0;

            for (const ws of this.clients) {
                // âœ… Terminate dead connections
                if (!ws.isAlive) {
                    logger.warn(`ğŸ’€ Terminating dead connection: ${ws.ip}`);
                    try {
                        ws.terminate();
                    } catch (error) {
                        logger.error('Error terminating connection:', error);
                    }
                    this.clients.delete(ws);
                    dead++;
                    continue;
                }

                // âœ… Send ping
                ws.isAlive = false;
                try {
                    ws.ping();
                    alive++;
                } catch (error) {
                    logger.error(`Error sending ping to ${ws.ip}:`, error);
                    this.clients.delete(ws);
                    dead++;
                }
            }

            if (alive > 0 || dead > 0) {
                logger.debug(`ğŸ’“ Heartbeat: ${alive} alive, ${dead} dead (cleaned)`);
            }
        }, 30000); // Every 30 seconds

        logger.info('âœ… Heartbeat started (30s interval)');
    }

    /**
     * âœ… Broadcast to all connected clients
     */
    broadcast(type, payload) {
        const data = JSON.stringify({ type, payload, timestamp: Date.now() });
        let sent = 0;
        let skipped = 0;

        for (const ws of this.clients) {
            // Check if client is subscribed to this event
            if (ws.subscriptions.length > 0 && 
                !ws.subscriptions.includes('all') && 
                !ws.subscriptions.includes(type)) {
                continue;
            }

            if (ws.readyState === ws.OPEN) {
                // Check backpressure
                if (ws.bufferedAmount < 512 * 1024) {
                    try {
                        ws.send(data);
                        sent++;
                    } catch (error) {
                        logger.error('Error broadcasting:', error);
                        skipped++;
                    }
                } else {
                    skipped++;
                }
            }
        }

        if (sent > 0) {
            logger.debug(`ğŸ“¡ Broadcast '${type}': ${sent} sent, ${skipped} skipped`);
        }

        this.emit('broadcast', type);
        return { sent, skipped };
    }

    /**
     * âœ… Get client count
     */
    getClientCount() {
        return this.clients.size;
    }

    /**
     * âœ… Get detailed stats
     */
    getStats() {
        let authenticated = 0;
        let alive = 0;
        let totalBuffered = 0;

        for (const ws of this.clients) {
            if (ws.isAuthenticated) authenticated++;
            if (ws.isAlive) alive++;
            totalBuffered += ws.bufferedAmount;
        }

        return {
            total: this.clients.size,
            authenticated,
            alive,
            dead: this.clients.size - alive,
            avgBuffered: this.clients.size > 0 ? Math.round(totalBuffered / this.clients.size) : 0
        };
    }

    /**
     * âœ… Shutdown gracefully
     */
    shutdown() {
        logger.info('ğŸ›‘ Shutting down WebSocket Server...');

        // Clear heartbeat
        if (this.heartbeatInterval) {
            clearInterval(this.heartbeatInterval);
        }

        // Close all connections
        for (const ws of this.clients) {
            try {
                ws.close(1000, 'Server shutting down');
            } catch (error) {
                logger.error('Error closing connection:', error);
            }
        }

        this.clients.clear();

        // Close server
        if (this.wss) {
            this.wss.close(() => {
                logger.info('âœ… WebSocket Server closed');
            });
        }
    }
}
```

---

###### **0.13.2 Client-Side Auto-Reconnect (RFC 6455)** ğŸ”„

**Implementation:**

```javascript
// /dashboard/src/hooks/useWebSocket.js
import { useEffect, useRef, useState, useCallback } from 'react';

/**
 * âœ… RFC 6455 Compliant WebSocket Hook with Auto-Reconnect
 */
export function useWebSocket() {
    const wsRef = useRef(null);
    const [connected, setConnected] = useState(false);
    const [reconnecting, setReconnecting] = useState(false);
    const attemptsRef = useRef(0);
    const reconnectTimeoutRef = useRef(null);

    /**
     * âœ… Calculate reconnect delay (Exponential Backoff + Jitter)
     */
    const getReconnectDelay = useCallback(() => {
        // Exponential backoff: 1s, 2s, 4s, 8s, 16s, 30s (max)
        const base = Math.min(1000 * Math.pow(2, attemptsRef.current), 30000);
        
        // Add random jitter (0-1000ms) to avoid thundering herd
        const jitter = Math.floor(Math.random() * 1000);
        
        return base + jitter;
    }, []);

    /**
     * âœ… Connect to WebSocket
     */
    const connect = useCallback(() => {
        try {
            const baseUrl = process.env.NEXT_PUBLIC_WS_URL || 'ws://localhost:8080';
            const apiKey = process.env.NEXT_PUBLIC_API_KEY || '';
            const url = `${baseUrl}/ws?apiKey=${apiKey}`;

            console.log(`ğŸ”Œ Connecting to WebSocket... (attempt ${attemptsRef.current + 1})`);

            const ws = new WebSocket(url);
            wsRef.current = ws;

            // âœ… Connection opened
            ws.onopen = () => {
                console.log('âœ… WebSocket connected');
                setConnected(true);
                setReconnecting(false);
                attemptsRef.current = 0; // Reset attempts on successful connection

                // Subscribe to all events
                ws.send(JSON.stringify({
                    type: 'subscribe',
                    events: ['all']
                }));
            };

            // âœ… Message received
            ws.onmessage = (event) => {
                try {
                    const msg = JSON.parse(event.data);
                    
                    // Dispatch custom event for each message type
                    window.dispatchEvent(
                        new CustomEvent(`ws:${msg.type}`, { 
                            detail: msg 
                        })
                    );

                    // Log important messages
                    if (msg.type !== 'pong') {
                        console.log(`ğŸ“¨ WebSocket message:`, msg.type, msg);
                    }
                } catch (error) {
                    console.error('âŒ Error parsing WebSocket message:', error);
                }
            };

            // âœ… Connection closed
            ws.onclose = (event) => {
                console.warn(`âš ï¸ WebSocket closed: code=${event.code}, reason=${event.reason}`);
                setConnected(false);
                
                // Auto-reconnect (unless closed intentionally with code 1000)
                if (event.code !== 1000) {
                    reconnect();
                }
            };

            // âœ… Connection error
            ws.onerror = (error) => {
                console.error('âŒ WebSocket error:', error);
                setConnected(false);
                ws.close();
            };
        } catch (error) {
            console.error('âŒ Failed to create WebSocket:', error);
            reconnect();
        }
    }, []);

    /**
     * âœ… Reconnect with exponential backoff
     */
    const reconnect = useCallback(() => {
        if (reconnectTimeoutRef.current) {
            clearTimeout(reconnectTimeoutRef.current);
        }

        attemptsRef.current++;
        const delay = getReconnectDelay();
        
        console.log(`ğŸ”„ Reconnecting in ${delay}ms... (attempt ${attemptsRef.current})`);
        setReconnecting(true);

        reconnectTimeoutRef.current = setTimeout(() => {
            connect();
        }, delay);
    }, [connect, getReconnectDelay]);

    /**
     * âœ… Send message
     */
    const send = useCallback((type, data) => {
        if (wsRef.current?.readyState === WebSocket.OPEN) {
            wsRef.current.send(JSON.stringify({ type, ...data }));
            return true;
        }
        console.warn('âš ï¸ Cannot send: WebSocket not connected');
        return false;
    }, []);

    /**
     * âœ… Subscribe to message type
     */
    const subscribe = useCallback((type, handler) => {
        const eventHandler = (event) => handler(event.detail);
        window.addEventListener(`ws:${type}`, eventHandler);
        
        return () => {
            window.removeEventListener(`ws:${type}`, eventHandler);
        };
    }, []);

    /**
     * âœ… Initialize connection
     */
    useEffect(() => {
        connect();

        return () => {
            // Cleanup
            if (reconnectTimeoutRef.current) {
                clearTimeout(reconnectTimeoutRef.current);
            }
            if (wsRef.current) {
                wsRef.current.close(1000, 'Component unmounted');
            }
        };
    }, [connect]);

    return {
        connected,
        reconnecting,
        attempts: attemptsRef.current,
        send,
        subscribe,
        ws: wsRef.current
    };
}
```

**Usage Example:**

```javascript
// /dashboard/src/components/Dashboard.jsx
import { useWebSocket } from '@/hooks/useWebSocket';
import { useEffect } from 'react';

export function Dashboard() {
    const { connected, reconnecting, attempts, subscribe } = useWebSocket();

    useEffect(() => {
        // Subscribe to session updates
        const unsubscribe = subscribe('session_update', (data) => {
            console.log('Session update:', data);
            // Update UI
        });

        return unsubscribe;
    }, [subscribe]);

    return (
        <div>
            <div className="connection-status">
                {connected && <span className="badge badge-success">ğŸŸ¢ Connected</span>}
                {reconnecting && <span className="badge badge-warning">ğŸŸ¡ Reconnecting... (attempt {attempts})</span>}
                {!connected && !reconnecting && <span className="badge badge-danger">ğŸ”´ Disconnected</span>}
            </div>
            {/* Rest of dashboard */}
        </div>
    );
}
```

---

###### **0.13.3 Testing Auto-Reconnect** ğŸ§ª

**Test Procedure:**

1. **Start Server:**
   ```bash
   npm run dev
   ```

2. **Open Dashboard:**
   - Navigate to `http://localhost:3000`
   - Check console: `âœ… WebSocket connected`

3. **Stop Server:**
   ```bash
   Ctrl + C
   ```

4. **Observe Reconnection:**
   - Console shows: `ğŸ”„ Reconnecting in 1000ms... (attempt 1)`
   - Then: `ğŸ”„ Reconnecting in 2000ms... (attempt 2)`
   - Then: `ğŸ”„ Reconnecting in 4000ms... (attempt 3)`
   - Max delay: 30 seconds

5. **Restart Server:**
   ```bash
   npm run dev
   ```

6. **Verify Auto-Reconnect:**
   - Console shows: `âœ… WebSocket connected`
   - Attempts reset to 0

**Expected Behavior:**

| Time | Client | Server |
|------|--------|--------|
| 0s | Connected âœ… | Client connected âœ… |
| 10s | Server stopped ğŸ›‘ | - |
| 11s | Reconnecting (1s delay) | - |
| 13s | Reconnecting (2s delay) | - |
| 17s | Reconnecting (4s delay) | - |
| 25s | Reconnecting (8s delay) | - |
| 30s | Server restarted âœ… | - |
| 31s | Connected âœ… | Client connected âœ… |

---

###### **0.13.4 RFC 6455 Compliance Summary** âœ…

**Protocol Compliance:**

1. **âœ… WebSocket Handshake (RFC 6455 Â§4)**
   - HTTP/1.1 Upgrade
   - Sec-WebSocket-Key validation
   - Sec-WebSocket-Accept response

2. **âœ… Frame Format (RFC 6455 Â§5)**
   - Binary and text frames
   - Fragmentation support
   - Control frames (ping/pong/close)

3. **âœ… Compression (RFC 7692)**
   - Per-message deflate
   - Context takeover control
   - Compression threshold

4. **âœ… Connection Management**
   - Heartbeat (ping/pong)
   - Dead connection detection
   - Graceful shutdown
   - Auto-reconnect with backoff

5. **âœ… Error Handling**
   - Close codes (1000, 1008, etc.)
   - Error events
   - Timeout handling

**Benefits:**

- ğŸš€ **Maximum Performance** - No overhead, pure WebSocket
- ğŸ”„ **Reliable Reconnection** - Exponential backoff + jitter
- ğŸ’“ **Health Monitoring** - Ping/pong every 30s
- ğŸ›¡ï¸ **Production Ready** - RFC 6455 compliant
- ğŸ“Š **Observable** - Detailed logging and metrics

---

##### **0.14 WebSocket Monitoring Dashboard** ğŸ“Š

**ğŸ¯ Ø§Ù„Ù‡Ø¯Ù:**
- Ù„ÙˆØ­Ø© Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ø­ØªØ±Ø§ÙÙŠØ© Ù…ØµØºÙ‘Ø±Ø© Ù„Ù„Ù€ WebSocket
- Ù…Ø±Ø§Ù‚Ø¨Ø© ÙÙŠ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ Ø¨Ø¯ÙˆÙ† Ù…ÙƒØªØ¨Ø§Øª Ø«Ù‚ÙŠÙ„Ø©
- Ø¯Ù…Ø¬ Ù…Ø¹ Dashboard Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø©
- Ø¹Ø±Ø¶ Metrics Ù…Ø¨Ø§Ø´Ø±Ø© Ù…Ù† Ø§Ù„Ù…ØªØµÙØ­

**Ø§Ù„Ù…Ù…ÙŠØ²Ø§Øª:**
- âœ… Ø¹Ø¯Ø¯ Ø§Ù„Ø§ØªØµØ§Ù„Ø§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ©
- âœ… Ø²Ù…Ù† Ø¢Ø®Ø± Ping Ù„ÙƒÙ„ Ø¹Ù…ÙŠÙ„
- âœ… Ø§Ø³ØªÙ‡Ù„Ø§Ùƒ Ø§Ù„Ø°Ø§ÙƒØ±Ø© ÙˆØ§Ù„Ù€ uptime
- âœ… Ø¹Ø¯Ø¯ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù…Ø±Ø³Ù„Ø© ÙˆØ§Ù„Ù…Ø³ØªÙ„Ù…Ø©
- âœ… Ø¢Ø®Ø± Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø¥Ù† ÙˆØ¬Ø¯Øª
- âœ… ØªØ­Ø¯ÙŠØ« ØªÙ„Ù‚Ø§Ø¦ÙŠ ÙƒÙ„ Ø«Ø§Ù†ÙŠØªÙŠÙ†

---

###### **0.14.1 Backend - Data Collection** ğŸ“ˆ

**Implementation:**

```javascript
// /runtime/server/services/websocketBridge.js
import os from 'os';
import process from 'process';
import { EventEmitter } from 'events';

export class WebSocketBridge extends EventEmitter {
    constructor(server, sessionMonitor) {
        super();
        this.server = server;
        this.sessionMonitor = sessionMonitor;
        this.clients = new Set();
        this.heartbeatInterval = null;
        
        // âœ… Statistics tracking
        this.stats = {
            connections: 0,
            disconnections: 0,
            messages: 0,
            broadcasts: 0,
            errors: 0,
            lastError: null,
            lastBroadcast: null,
            startTime: Date.now()
        };
    }

    setupEvents() {
        this.wss.on('connection', (ws, req) => {
            // âœ… Initialize connection state
            ws.isAlive = true;
            ws.ip = req.socket.remoteAddress;
            ws.connectedAt = Date.now();
            ws.lastPing = Date.now();
            ws.subscriptions = [];

            // âœ… Increment connection counter
            this.stats.connections++;

            logger.info(`âœ… Client connected: ${ws.ip} (total: ${this.clients.size + 1})`);

            // âœ… Pong handler - mark as alive and update last ping
            ws.on('pong', () => {
                ws.isAlive = true;
                ws.lastPing = Date.now();
                logger.debug(`ğŸ’“ Pong received from ${ws.ip}`);
            });

            // âœ… Add to clients set
            this.clients.add(ws);
            this.emit('connection');

            // âœ… Send welcome message
            this.safeSend(ws, {
                type: 'welcome',
                message: 'Connected successfully',
                timestamp: Date.now(),
                server: 'WaQtor WebSocket Server v1.0'
            });

            // âœ… Handle incoming messages
            ws.on('message', (data) => {
                this.stats.messages++;
                this.handleMessage(ws, data);
            });

            // âœ… Handle close
            ws.on('close', (code, reason) => {
                this.clients.delete(ws);
                this.stats.disconnections++;
                const duration = Date.now() - ws.connectedAt;
                logger.info(`âŒ Client disconnected: ${ws.ip} (code: ${code}, duration: ${Math.round(duration/1000)}s, total: ${this.clients.size})`);
                this.emit('disconnect');
            });

            // âœ… Handle errors
            ws.on('error', (error) => {
                this.logError(error, ws.ip);
                this.emit('error', error);
            });
        });

        this.wss.on('error', (error) => {
            this.logError(error, 'server');
        });
    }

    broadcast(type, payload) {
        // âœ… Track broadcast
        this.stats.broadcasts++;
        this.stats.lastBroadcast = new Date().toISOString();

        const data = JSON.stringify({ type, payload, timestamp: Date.now() });
        let sent = 0;
        let skipped = 0;

        for (const ws of this.clients) {
            // Check if client is subscribed to this event
            if (ws.subscriptions.length > 0 && 
                !ws.subscriptions.includes('all') && 
                !ws.subscriptions.includes(type)) {
                continue;
            }

            if (ws.readyState === ws.OPEN) {
                // Check backpressure
                if (ws.bufferedAmount < 512 * 1024) {
                    try {
                        ws.send(data);
                        sent++;
                    } catch (error) {
                        this.logError(error, 'broadcast');
                        skipped++;
                    }
                } else {
                    skipped++;
                }
            }
        }

        if (sent > 0) {
            logger.debug(`ğŸ“¡ Broadcast '${type}': ${sent} sent, ${skipped} skipped`);
        }

        this.emit('broadcast', type);
        return { sent, skipped };
    }

    /**
     * âœ… Log error with tracking
     */
    logError(err, source = 'unknown') {
        this.stats.errors++;
        this.stats.lastError = {
            time: new Date().toISOString(),
            message: err.message || String(err),
            source,
            stack: err.stack ? err.stack.split('\n').slice(0, 3).join('\n') : null
        };
        logger.error(`[WS ERROR from ${source}]:`, err);
    }

    /**
     * âœ… Get comprehensive metrics
     */
    getMetrics() {
        const now = Date.now();
        const clients = [];
        let totalBuffered = 0;
        let aliveCount = 0;

        // âœ… Collect per-client metrics
        for (const ws of this.clients) {
            const lastPingAge = ws.lastPing ? now - ws.lastPing : null;
            const connectedDuration = now - ws.connectedAt;
            
            clients.push({
                ip: ws.ip,
                connected: Math.round(connectedDuration / 1000), // seconds
                lastPing: lastPingAge ? Math.round(lastPingAge / 1000) : null, // seconds
                isAlive: ws.isAlive,
                buffered: Math.round(ws.bufferedAmount / 1024), // KB
                subscriptions: ws.subscriptions
            });

            totalBuffered += ws.bufferedAmount;
            if (ws.isAlive) aliveCount++;
        }

        // âœ… System metrics
        const memUsage = process.memoryUsage();
        const uptime = process.uptime();

        return {
            // Server info
            server: {
                uptime: Math.round(uptime),
                uptimeFormatted: this.formatUptime(uptime * 1000),
                startTime: new Date(now - uptime * 1000).toISOString(),
                timestamp: new Date().toISOString()
            },

            // Connection stats
            connections: {
                current: this.clients.size,
                total: this.stats.connections,
                disconnections: this.stats.disconnections,
                alive: aliveCount,
                dead: this.clients.size - aliveCount
            },

            // Message stats
            messages: {
                received: this.stats.messages,
                broadcasts: this.stats.broadcasts,
                lastBroadcast: this.stats.lastBroadcast
            },

            // Error stats
            errors: {
                total: this.stats.errors,
                last: this.stats.lastError
            },

            // System resources
            system: {
                memory: {
                    rss: Math.round(memUsage.rss / 1024 / 1024), // MB
                    heapUsed: Math.round(memUsage.heapUsed / 1024 / 1024), // MB
                    heapTotal: Math.round(memUsage.heapTotal / 1024 / 1024), // MB
                    external: Math.round(memUsage.external / 1024 / 1024) // MB
                },
                cpu: {
                    loadAvg: os.loadavg().map(l => l.toFixed(2)),
                    cores: os.cpus().length
                }
            },

            // Buffer stats
            buffer: {
                total: Math.round(totalBuffered / 1024), // KB
                average: this.clients.size > 0 ? Math.round(totalBuffered / this.clients.size / 1024) : 0 // KB
            },

            // Client details
            clients: clients.sort((a, b) => b.connected - a.connected) // Sort by connection time
        };
    }

    /**
     * âœ… Format uptime
     */
    formatUptime(ms) {
        const seconds = Math.floor(ms / 1000);
        const minutes = Math.floor(seconds / 60);
        const hours = Math.floor(minutes / 60);
        const days = Math.floor(hours / 24);
        
        if (days > 0) return `${days}d ${hours % 24}h ${minutes % 60}m`;
        if (hours > 0) return `${hours}h ${minutes % 60}m ${seconds % 60}s`;
        if (minutes > 0) return `${minutes}m ${seconds % 60}s`;
        return `${seconds}s`;
    }
}
```

---

###### **0.14.2 Backend - Monitoring Endpoint** ğŸ”Œ

**Implementation:**

```javascript
// /runtime/server/index.js

// âœ… WebSocket Monitoring Endpoint
app.get('/api/ws-monitor', (req, res) => {
    try {
        const metrics = websocketBridge.getMetrics();
        res.json(metrics);
    } catch (error) {
        logger.error('Error fetching WebSocket metrics:', error);
        res.status(500).json({ 
            error: 'Failed to fetch metrics',
            message: error.message 
        });
    }
});

// âœ… Serve static files for monitoring dashboard
app.use(express.static('runtime/server/public'));
```

---

###### **0.14.3 Frontend - Monitoring Dashboard** ğŸ¨

**Create File: `/runtime/server/public/ws-monitor.html`**

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebSocket Monitor - WaQtor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            color: #e2e8f0;
            padding: 2rem;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            color: #38bdf8;
            font-size: 2rem;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .subtitle {
            color: #94a3b8;
            margin-bottom: 2rem;
            font-size: 0.9rem;
        }

        .status-badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: bold;
            margin-left: 1rem;
        }

        .status-online {
            background: #10b981;
            color: white;
        }

        .status-offline {
            background: #ef4444;
            color: white;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .card {
            background: rgba(30, 41, 59, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 1.5rem;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(56, 189, 248, 0.1);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(56, 189, 248, 0.2);
        }

        .card-title {
            color: #38bdf8;
            font-size: 0.875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .card-value {
            font-size: 2.5rem;
            font-weight: bold;
            color: #f8fafc;
            line-height: 1;
        }

        .card-label {
            color: #94a3b8;
            font-size: 0.875rem;
            margin-top: 0.5rem;
        }

        .metric-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 0;
            border-bottom: 1px solid rgba(148, 163, 184, 0.1);
        }

        .metric-row:last-child {
            border-bottom: none;
        }

        .metric-key {
            color: #94a3b8;
            font-size: 0.875rem;
        }

        .metric-value {
            color: #f8fafc;
            font-weight: 600;
            font-size: 0.875rem;
        }

        .clients-table {
            width: 100%;
            margin-top: 1rem;
        }

        .clients-table th {
            text-align: left;
            padding: 0.75rem;
            background: rgba(56, 189, 248, 0.1);
            color: #38bdf8;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .clients-table td {
            padding: 0.75rem;
            border-bottom: 1px solid rgba(148, 163, 184, 0.1);
            font-size: 0.875rem;
        }

        .clients-table tr:hover {
            background: rgba(56, 189, 248, 0.05);
        }

        .badge {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .badge-success {
            background: #10b981;
            color: white;
        }

        .badge-danger {
            background: #ef4444;
            color: white;
        }

        .badge-warning {
            background: #f59e0b;
            color: white;
        }

        .error-card {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        .error-message {
            color: #fca5a5;
            font-size: 0.875rem;
            margin-top: 0.5rem;
            font-family: 'Courier New', monospace;
        }

        .loading {
            text-align: center;
            padding: 3rem;
            color: #94a3b8;
        }

        .refresh-indicator {
            position: fixed;
            top: 1rem;
            right: 1rem;
            background: rgba(56, 189, 248, 0.2);
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-size: 0.75rem;
            color: #38bdf8;
            backdrop-filter: blur(10px);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .pulse {
            animation: pulse 2s ease-in-out infinite;
        }
    </style>
</head>
<body>
    <div class="refresh-indicator pulse">ğŸ”„ Auto-refresh: 2s</div>
    
    <div class="container">
        <h1>
            ğŸ“Š WebSocket Monitor
            <span class="status-badge status-online" id="status">Online</span>
        </h1>
        <p class="subtitle">Real-time monitoring dashboard for WaQtor WebSocket Server</p>

        <div id="metrics" class="loading">
            <p>Loading metrics...</p>
        </div>
    </div>

    <script>
        let lastUpdate = null;

        async function fetchMetrics() {
            try {
                const res = await fetch('/api/ws-monitor');
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                
                const data = await res.json();
                lastUpdate = new Date();
                render(data);
                updateStatus(true);
            } catch (error) {
                console.error('Error fetching metrics:', error);
                updateStatus(false);
                document.getElementById('metrics').innerHTML = `
                    <div class="card error-card">
                        <div class="card-title">âŒ Error</div>
                        <div class="error-message">Failed to fetch metrics: ${error.message}</div>
                    </div>
                `;
            }
        }

        function updateStatus(online) {
            const badge = document.getElementById('status');
            if (online) {
                badge.textContent = 'Online';
                badge.className = 'status-badge status-online';
            } else {
                badge.textContent = 'Offline';
                badge.className = 'status-badge status-offline';
            }
        }

        function render(data) {
            const html = `
                <!-- Overview Cards -->
                <div class="grid">
                    <div class="card">
                        <div class="card-title">ğŸ‘¥ Active Connections</div>
                        <div class="card-value">${data.connections.current}</div>
                        <div class="card-label">
                            ${data.connections.alive} alive, ${data.connections.dead} dead
                        </div>
                    </div>

                    <div class="card">
                        <div class="card-title">ğŸ“¨ Messages</div>
                        <div class="card-value">${data.messages.received.toLocaleString()}</div>
                        <div class="card-label">
                            ${data.messages.broadcasts.toLocaleString()} broadcasts
                        </div>
                    </div>

                    <div class="card">
                        <div class="card-title">â±ï¸ Uptime</div>
                        <div class="card-value" style="font-size: 1.5rem">${data.server.uptimeFormatted}</div>
                        <div class="card-label">
                            Started: ${new Date(data.server.startTime).toLocaleString()}
                        </div>
                    </div>

                    <div class="card">
                        <div class="card-title">ğŸ’¾ Memory</div>
                        <div class="card-value">${data.system.memory.rss} MB</div>
                        <div class="card-label">
                            Heap: ${data.system.memory.heapUsed}/${data.system.memory.heapTotal} MB
                        </div>
                    </div>
                </div>

                <!-- Detailed Stats -->
                <div class="grid">
                    <div class="card">
                        <div class="card-title">ğŸ“Š Connection Stats</div>
                        <div class="metric-row">
                            <span class="metric-key">Total Connections</span>
                            <span class="metric-value">${data.connections.total}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-key">Total Disconnections</span>
                            <span class="metric-value">${data.connections.disconnections}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-key">Current Active</span>
                            <span class="metric-value">${data.connections.current}</span>
                        </div>
                    </div>

                    <div class="card">
                        <div class="card-title">ğŸ–¥ï¸ System Resources</div>
                        <div class="metric-row">
                            <span class="metric-key">CPU Load (1m)</span>
                            <span class="metric-value">${data.system.cpu.loadAvg[0]}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-key">CPU Cores</span>
                            <span class="metric-value">${data.system.cpu.cores}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-key">Buffer Total</span>
                            <span class="metric-value">${data.buffer.total} KB</span>
                        </div>
                    </div>

                    ${data.errors.last ? `
                    <div class="card error-card">
                        <div class="card-title">âš ï¸ Last Error</div>
                        <div class="metric-row">
                            <span class="metric-key">Time</span>
                            <span class="metric-value">${new Date(data.errors.last.time).toLocaleString()}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-key">Source</span>
                            <span class="metric-value">${data.errors.last.source}</span>
                        </div>
                        <div class="error-message">${data.errors.last.message}</div>
                    </div>
                    ` : ''}
                </div>

                <!-- Connected Clients -->
                ${data.clients.length > 0 ? `
                <div class="card">
                    <div class="card-title">ğŸ‘¤ Connected Clients (${data.clients.length})</div>
                    <table class="clients-table">
                        <thead>
                            <tr>
                                <th>IP Address</th>
                                <th>Connected</th>
                                <th>Last Ping</th>
                                <th>Status</th>
                                <th>Buffer</th>
                                <th>Subscriptions</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${data.clients.map(client => `
                                <tr>
                                    <td>${client.ip}</td>
                                    <td>${client.connected}s</td>
                                    <td>${client.lastPing ? client.lastPing + 's ago' : 'N/A'}</td>
                                    <td>
                                        <span class="badge ${client.isAlive ? 'badge-success' : 'badge-danger'}">
                                            ${client.isAlive ? 'âœ“ Alive' : 'âœ— Dead'}
                                        </span>
                                    </td>
                                    <td>${client.buffered} KB</td>
                                    <td>${client.subscriptions.join(', ') || 'none'}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
                ` : ''}
            `;

            document.getElementById('metrics').innerHTML = html;
        }

        // Auto-refresh every 2 seconds
        setInterval(fetchMetrics, 2000);
        fetchMetrics();
    </script>
</body>
</html>
```

---

###### **0.14.4 Access & Usage** ğŸš€

**Access URLs:**

1. **JSON API:**
   ```
   http://localhost:8080/api/ws-monitor
   ```

2. **Dashboard:**
   ```
   http://localhost:8080/ws-monitor.html
   ```

**Response Example:**

```json
{
  "server": {
    "uptime": 3600,
    "uptimeFormatted": "1h 0m 0s",
    "startTime": "2025-10-31T04:35:00.000Z",
    "timestamp": "2025-10-31T05:35:00.000Z"
  },
  "connections": {
    "current": 5,
    "total": 150,
    "disconnections": 145,
    "alive": 5,
    "dead": 0
  },
  "messages": {
    "received": 5234,
    "broadcasts": 1523,
    "lastBroadcast": "2025-10-31T05:34:58.123Z"
  },
  "errors": {
    "total": 2,
    "last": {
      "time": "2025-10-31T05:30:00.000Z",
      "message": "Connection timeout",
      "source": "192.168.1.100"
    }
  },
  "system": {
    "memory": {
      "rss": 128,
      "heapUsed": 64,
      "heapTotal": 96,
      "external": 8
    },
    "cpu": {
      "loadAvg": ["0.52", "0.48", "0.45"],
      "cores": 8
    }
  },
  "buffer": {
    "total": 10,
    "average": 2
  },
  "clients": [
    {
      "ip": "192.168.1.100",
      "connected": 120,
      "lastPing": 5,
      "isAlive": true,
      "buffered": 2,
      "subscriptions": ["all"]
    }
  ]
}
```

---

###### **0.14.5 Future Enhancements** ğŸ”®

**Optional Extensions:**

1. **Graphs & Charts:**
   ```javascript
   // Add Chart.js or Recharts
   <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
   
   // Create real-time line chart for connections
   const ctx = document.getElementById('connectionsChart');
   const chart = new Chart(ctx, {
       type: 'line',
       data: { /* ... */ }
   });
   ```

2. **Alerts & Notifications:**
   ```javascript
   // Alert on high error rate
   if (data.errors.total > threshold) {
       showNotification('High error rate detected!');
   }
   ```

3. **Log Snapshots:**
   ```javascript
   // Save metrics every 5 minutes
   setInterval(() => {
       const metrics = websocketBridge.getMetrics();
       fs.appendFileSync(
           'runtime/logs/ws-metrics.log',
           JSON.stringify(metrics) + '\n'
       );
   }, 5 * 60 * 1000);
   ```

4. **Authentication:**
   ```javascript
   // Protect monitoring endpoint
   app.get('/api/ws-monitor', authenticateApiKey, (req, res) => {
       // ...
   });
   ```

---

###### **0.14.6 Benefits** âœ¨

**Ø§Ù„ÙÙˆØ§Ø¦Ø¯:**

1. **âœ… Real-Time Monitoring**
   - ØªØ­Ø¯ÙŠØ« ØªÙ„Ù‚Ø§Ø¦ÙŠ ÙƒÙ„ Ø«Ø§Ù†ÙŠØªÙŠÙ†
   - Ø¹Ø±Ø¶ Ù…Ø¨Ø§Ø´Ø± Ù„Ù„Ø§ØªØµØ§Ù„Ø§Øª Ø§Ù„Ø­ÙŠØ©
   - ØªØªØ¨Ø¹ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ ÙÙˆØ±Ø§Ù‹

2. **âœ… Zero Dependencies**
   - Ø¨Ø¯ÙˆÙ† Ù…ÙƒØªØ¨Ø§Øª Ø®Ø§Ø±Ø¬ÙŠØ© Ø«Ù‚ÙŠÙ„Ø©
   - HTML/CSS/JS Ø®Ø§Ù… ÙÙ‚Ø·
   - Ø³Ø±ÙŠØ¹ ÙˆØ®ÙÙŠÙ

3. **âœ… Production Ready**
   - ÙŠØ¹Ù…Ù„ Ù…Ø­Ù„ÙŠØ§Ù‹ ÙˆØ¹Ù„Ù‰ Ø§Ù„Ø³ÙŠØ±ÙØ±
   - Ù„Ø§ ÙŠØ¤Ø«Ø± Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø¯Ø§Ø¡
   - Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ù…Ø¨Ø§Ø´Ø±Ø©

4. **âœ… Comprehensive Metrics**
   - Ø§ØªØµØ§Ù„Ø§Øª (current, total, alive, dead)
   - Ø±Ø³Ø§Ø¦Ù„ (received, broadcasts)
   - Ù†Ø¸Ø§Ù… (memory, CPU, uptime)
   - Ø¹Ù…Ù„Ø§Ø¡ (IP, ping, buffer, subscriptions)
   - Ø£Ø®Ø·Ø§Ø¡ (total, last error details)

5. **âœ… Beautiful UI**
   - ØªØµÙ…ÙŠÙ… Ø§Ø­ØªØ±Ø§ÙÙŠ Ù…Ø¹ gradients
   - Responsive design
   - Dark theme
   - Real-time updates
   - Status badges

---

#### **1. Database Ù„Ù„Ù€ Notifications** ğŸ—„ï¸

**Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©:**
```javascript
// /runtime/server/routes/notifications.js
let notifications = [];  // âŒ In-memory (ÙŠÙÙÙ‚Ø¯ Ø¹Ù†Ø¯ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ´ØºÙŠÙ„)
```

**Ø§Ù„Ù…Ø·Ù„ÙˆØ¨:**
- âœ… Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ø¯ÙˆÙ„ `notifications` ÙÙŠ SQLite
- âœ… Migration Ù…Ù† in-memory Ø¥Ù„Ù‰ database
- âœ… CRUD operations Ø¹Ø¨Ø± database
- âœ… Indexing Ù„Ù„Ø£Ø¯Ø§Ø¡ (userId, read, createdAt)
- âœ… Auto-cleanup Ù„Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© (>30 ÙŠÙˆÙ…)

**Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©:**
```
/runtime/server/
â”œâ”€â”€ database/
â”‚   â”œâ”€â”€ schema/
â”‚   â”‚   â””â”€â”€ notifications.sql          â† Ø¬Ø¯ÙŠØ¯
â”‚   â””â”€â”€ models/
â”‚       â””â”€â”€ Notification.js             â† Ø¬Ø¯ÙŠØ¯
â””â”€â”€ routes/
    â””â”€â”€ notifications.js                â† ØªØ­Ø¯ÙŠØ«
```

**Schema Ø§Ù„Ù…Ù‚ØªØ±Ø­:**
```sql
-- notifications.sql
CREATE TABLE IF NOT EXISTS notifications (
    id TEXT PRIMARY KEY,
    userId TEXT NOT NULL,
    type TEXT NOT NULL CHECK(type IN ('info', 'success', 'warning', 'error')),
    title TEXT NOT NULL,
    message TEXT NOT NULL,
    icon TEXT,
    link TEXT,
    read INTEGER DEFAULT 0,
    createdAt TEXT NOT NULL,
    updatedAt TEXT,
    FOREIGN KEY (userId) REFERENCES users(id) ON DELETE CASCADE
);

-- Indexes Ù„Ù„Ø£Ø¯Ø§Ø¡
CREATE INDEX idx_notifications_userId ON notifications(userId);
CREATE INDEX idx_notifications_read ON notifications(read);
CREATE INDEX idx_notifications_createdAt ON notifications(createdAt);
CREATE INDEX idx_notifications_userId_read ON notifications(userId, read);
```

**Model Ø§Ù„Ù…Ù‚ØªØ±Ø­:**
```javascript
// Notification.js
class NotificationModel {
    constructor(db) {
        this.db = db;
    }

    async create(notification) {
        const query = `
            INSERT INTO notifications (id, userId, type, title, message, icon, link, read, createdAt)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `;
        await this.db.run(query, [
            notification.id,
            notification.userId,
            notification.type,
            notification.title,
            notification.message,
            notification.icon || null,
            notification.link || null,
            notification.read ? 1 : 0,
            notification.createdAt
        ]);
        return notification;
    }

    async findByUserId(userId, filter = 'all', limit = 50) {
        let query = `SELECT * FROM notifications WHERE userId = ?`;
        const params = [userId];

        if (filter === 'unread') {
            query += ` AND read = 0`;
        }

        query += ` ORDER BY createdAt DESC LIMIT ?`;
        params.push(limit);

        return await this.db.all(query, params);
    }

    async getUnreadCount(userId) {
        const query = `SELECT COUNT(*) as count FROM notifications WHERE userId = ? AND read = 0`;
        const result = await this.db.get(query, [userId]);
        return result.count;
    }

    async markAsRead(id) {
        const query = `UPDATE notifications SET read = 1, updatedAt = ? WHERE id = ?`;
        await this.db.run(query, [new Date().toISOString(), id]);
    }

    async markAllAsRead(userId) {
        const query = `UPDATE notifications SET read = 1, updatedAt = ? WHERE userId = ? AND read = 0`;
        await this.db.run(query, [new Date().toISOString(), userId]);
    }

    async delete(id) {
        const query = `DELETE FROM notifications WHERE id = ?`;
        await this.db.run(query, [id]);
    }

    async cleanup(daysOld = 30) {
        const cutoffDate = new Date();
        cutoffDate.setDate(cutoffDate.getDate() - daysOld);
        
        const query = `DELETE FROM notifications WHERE createdAt < ?`;
        const result = await this.db.run(query, [cutoffDate.toISOString()]);
        return result.changes;
    }
}

module.exports = NotificationModel;
```

**Migration Plan:**
```javascript
// 1. Create table
// 2. Migrate existing in-memory data (if any)
// 3. Update routes to use model
// 4. Test CRUD operations
// 5. Setup auto-cleanup cron job
```

---

#### **2. Rate Limiting Ù„Ù„Ù€ WebSocket** ğŸ›¡ï¸

**Ø§Ù„Ù…Ø´ÙƒÙ„Ø©:**
- Ø­Ø§Ù„ÙŠØ§Ù‹ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø­Ù…Ø§ÙŠØ© Ù…Ù† spam messages
- Client ÙŠÙ…ÙƒÙ†Ù‡ Ø¥Ø±Ø³Ø§Ù„ unlimited messages

**Ø§Ù„Ù…Ø·Ù„ÙˆØ¨:**
- âœ… Rate limiting per client
- âœ… Configurable limits (messages/second)
- âœ… Auto-disconnect Ø¹Ù„Ù‰ Ø§Ù„ØªØ¬Ø§ÙˆØ²
- âœ… Whitelist Ù„Ù„Ù€ trusted clients

**Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©:**
```
/runtime/server/
â”œâ”€â”€ middleware/
â”‚   â””â”€â”€ websocketRateLimit.js          â† Ø¬Ø¯ÙŠØ¯
â””â”€â”€ services/
    â””â”€â”€ websocketBridge.js              â† ØªØ­Ø¯ÙŠØ«
```

**Implementation Ø§Ù„Ù…Ù‚ØªØ±Ø­:**
```javascript
// websocketRateLimit.js
class WebSocketRateLimit {
    constructor(options = {}) {
        this.maxMessages = options.maxMessages || 10;  // 10 messages
        this.windowMs = options.windowMs || 1000;      // per second
        this.whitelist = new Set(options.whitelist || []);
        this.clients = new Map();
    }

    check(clientId) {
        // Skip whitelist
        if (this.whitelist.has(clientId)) {
            return { allowed: true };
        }

        const now = Date.now();
        const clientData = this.clients.get(clientId) || {
            messages: [],
            violations: 0
        };

        // Remove old messages outside window
        clientData.messages = clientData.messages.filter(
            timestamp => now - timestamp < this.windowMs
        );

        // Check limit
        if (clientData.messages.length >= this.maxMessages) {
            clientData.violations++;
            this.clients.set(clientId, clientData);
            
            return {
                allowed: false,
                violations: clientData.violations,
                retryAfter: this.windowMs - (now - clientData.messages[0])
            };
        }

        // Add message
        clientData.messages.push(now);
        this.clients.set(clientId, clientData);

        return { allowed: true };
    }

    reset(clientId) {
        this.clients.delete(clientId);
    }

    addToWhitelist(clientId) {
        this.whitelist.add(clientId);
    }

    removeFromWhitelist(clientId) {
        this.whitelist.delete(clientId);
    }
}

module.exports = WebSocketRateLimit;
```

**Integration ÙÙŠ WebSocketBridge:**
```javascript
// websocketBridge.js
const WebSocketRateLimit = require('../middleware/websocketRateLimit');

class WebSocketBridge {
    constructor(server, sessionMonitor) {
        // ... existing code
        this.rateLimit = new WebSocketRateLimit({
            maxMessages: 10,    // 10 messages
            windowMs: 1000,     // per second
            whitelist: []       // trusted clients
        });
    }

    handleClientMessage(ws, message) {
        // Rate limiting check
        const clientId = ws.clientId || ws._socket.remoteAddress;
        const rateLimitResult = this.rateLimit.check(clientId);

        if (!rateLimitResult.allowed) {
            logger.warn(`Rate limit exceeded for client ${clientId}`, {
                violations: rateLimitResult.violations
            });

            // Send warning
            this.send(ws, {
                type: 'rate_limit_exceeded',
                message: 'Too many messages. Please slow down.',
                retryAfter: rateLimitResult.retryAfter
            });

            // Auto-disconnect after 3 violations
            if (rateLimitResult.violations >= 3) {
                logger.error(`Client ${clientId} disconnected due to rate limit violations`);
                ws.close(1008, 'Rate limit exceeded');
                this.rateLimit.reset(clientId);
            }

            return;
        }

        // ... existing message handling
    }
}
```

**Configuration:**
```javascript
// .env
WEBSOCKET_RATE_LIMIT_MAX_MESSAGES=10
WEBSOCKET_RATE_LIMIT_WINDOW_MS=1000
WEBSOCKET_RATE_LIMIT_MAX_VIOLATIONS=3
```

---

#### **3. Compression Ù„Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„ÙƒØ¨ÙŠØ±Ø©** ğŸ“¦

**Ø§Ù„Ù…Ø´ÙƒÙ„Ø©:**
- Ø±Ø³Ø§Ø¦Ù„ ÙƒØ¨ÙŠØ±Ø© (Ù…Ø«Ù„ campaign data) ØªØ³ØªÙ‡Ù„Ùƒ bandwidth
- Ù„Ø§ ÙŠÙˆØ¬Ø¯ compression Ø­Ø§Ù„ÙŠØ§Ù‹

**Ø§Ù„Ù…Ø·Ù„ÙˆØ¨:**
- âœ… Auto-compression Ù„Ù„Ø±Ø³Ø§Ø¦Ù„ > 1KB
- âœ… Support Ù„Ù€ gzip/deflate
- âœ… Client-side decompression
- âœ… Fallback Ù„Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„ØµØºÙŠØ±Ø©

**Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©:**
```
/runtime/server/
â””â”€â”€ services/
    â””â”€â”€ websocketBridge.js              â† ØªØ­Ø¯ÙŠØ«

/dashboard/src/
â””â”€â”€ hooks/
    â””â”€â”€ useWebSocket.js                 â† ØªØ­Ø¯ÙŠØ«
```

**Backend Implementation:**
```javascript
// websocketBridge.js
const zlib = require('zlib');
const { promisify } = require('util');
const gzip = promisify(zlib.gzip);

class WebSocketBridge {
    constructor(server, sessionMonitor) {
        // ... existing code
        this.compressionThreshold = 1024; // 1KB
        this.compressionEnabled = process.env.WEBSOCKET_COMPRESSION === 'true';
    }

    async send(ws, data) {
        if (ws.readyState !== WebSocket.OPEN) return;

        const message = JSON.stringify(data);
        const messageSize = Buffer.byteLength(message);

        // Compress if enabled and message is large
        if (this.compressionEnabled && messageSize > this.compressionThreshold) {
            try {
                const compressed = await gzip(message);
                
                // Send compressed with metadata
                ws.send(JSON.stringify({
                    compressed: true,
                    data: compressed.toString('base64'),
                    originalSize: messageSize,
                    compressedSize: compressed.length
                }));

                logger.debug(`Compressed message: ${messageSize}B â†’ ${compressed.length}B (${Math.round((1 - compressed.length/messageSize) * 100)}% reduction)`);
            } catch (error) {
                logger.error('Compression failed, sending uncompressed:', error);
                ws.send(message);
            }
        } else {
            ws.send(message);
        }
    }

    async broadcast(type, data) {
        const message = {
            type,
            data,
            timestamp: Date.now()
        };

        let sent = 0;
        for (const client of this.clients) {
            if (client.readyState === WebSocket.OPEN && client.isAuthenticated) {
                if (!client.subscriptions || 
                    client.subscriptions.includes('all') || 
                    client.subscriptions.includes(type)) {
                    await this.send(client, message);
                    sent++;
                }
            }
        }

        if (sent > 0) {
            logger.debug(`Broadcast sent to ${sent} clients: ${type}`);
        }
    }
}
```

**Frontend Implementation:**
```javascript
// useWebSocket.js
import pako from 'pako';  // npm install pako

ws.onmessage = async (event) => {
    try {
        const rawData = JSON.parse(event.data);

        // Check if compressed
        if (rawData.compressed) {
            // Decompress
            const compressedData = Uint8Array.from(atob(rawData.data), c => c.charCodeAt(0));
            const decompressed = pako.ungzip(compressedData, { to: 'string' });
            const data = JSON.parse(decompressed);

            console.log(`ğŸ“¦ Decompressed: ${rawData.compressedSize}B â†’ ${rawData.originalSize}B`);
            
            // Handle decompressed data
            handleMessage(data);
        } else {
            // Handle normal data
            handleMessage(rawData);
        }
    } catch (err) {
        console.error('âŒ Error parsing WebSocket message:', err);
    }
};
```

**Configuration:**
```javascript
// .env
WEBSOCKET_COMPRESSION=true
WEBSOCKET_COMPRESSION_THRESHOLD=1024
```

**Dependencies:**
```json
// Backend: Built-in zlib
// Frontend: 
{
  "dependencies": {
    "pako": "^2.1.0"  // gzip/deflate for browser
  }
}
```

---

### **ğŸ“Š Performance Metrics:**

**Before:**
```
- Notifications: In-memory (lost on restart)
- WebSocket: No rate limiting
- Messages: No compression
- Average message size: 2-5KB
- Bandwidth usage: High for large campaigns
```

**After:**
```
- Notifications: SQLite (persistent + indexed)
- WebSocket: 10 msg/sec limit
- Messages: Auto-compress >1KB
- Average message size: 0.5-2KB (60% reduction)
- Bandwidth usage: Reduced by ~40-60%
```

---

### **ğŸ”„ Migration Plan:**

**Phase 1: Database (Week 1)**
1. Create schema
2. Create model
3. Update routes
4. Test CRUD
5. Setup cleanup cron

**Phase 2: Rate Limiting (Week 1)**
1. Create middleware
2. Integrate in WebSocketBridge
3. Test limits
4. Monitor violations

**Phase 3: Compression (Week 2)**
1. Backend implementation
2. Frontend implementation
3. Test compression ratio
4. Monitor performance

**Phase 4: Testing & Deployment (Week 2)**
1. Integration testing
2. Load testing
3. Documentation
4. Production deployment

---

### **âœ… Success Criteria:**

- âœ… Notifications persist across restarts
- âœ… Database queries < 50ms
- âœ… Rate limiting blocks spam
- âœ… Compression reduces bandwidth by >40%
- âœ… No breaking changes to existing features
- âœ… Full backward compatibility

---

### **ğŸ“ Notes:**

**Database Choice:**
- SQLite: âœ… Ù…ÙÙˆØµÙ‰ Ø¨Ù‡ (Ø®ÙÙŠÙØŒ Ø³Ø±ÙŠØ¹ØŒ Ù„Ø§ ÙŠØ­ØªØ§Ø¬ server)
- PostgreSQL: Ù„Ù„Ù…Ø´Ø§Ø±ÙŠØ¹ Ø§Ù„ÙƒØ¨ÙŠØ±Ø© Ø¬Ø¯Ø§Ù‹

**Rate Limiting:**
- Default: 10 msg/sec
- Configurable per environment
- Whitelist Ù„Ù„Ù€ admin clients

**Compression:**
- Auto-enabled for messages >1KB
- Uses gzip (best compression ratio)
- Fallback to uncompressed on error

---

**Status:** ğŸ“‹ **PLANNED** - Ready for implementation!

---

**Ø¬Ø§Ù‡Ø² Ù„Ù„Ø¨Ø¯Ø¡! ğŸš€**
